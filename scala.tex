%% config
\newcommand{\home}{../../latex/styles}

%% documentclass
\input{\home/documentclass_normal_oneside}

%% generell-styling
\input{\home/style_proggen}

%% meta-tags for pdf
\input{tex/metatags.tex}

%% label for programming-language
\input{\home/style_scala}

%% fancy-header
\input{\home/style_header_oneside}

%% setting the infos for the pdf
\input{\home/info_hypersetup}

%% environments
\input{\home/environments_normal}

%% cover
%\input{\home/style_cover}

\begin{document}
\input{\home/style_starting_document_without_cover}
%style_starting_document_complete

\section{Einführung}
Alles was ich dazu sagen ist etwas ganz anderes oder was denkst du?
\begin{itemize}
  \item \textbf{Kompilierung}: \texttt{scalac}\footnote{Resultat sind JVM
  Klassen-Datein, welche man in JARs packen kann, hierbei wird jedoch class,
  trait \oder object-Definition verlangt} bzw. 
  \texttt{fsc}\footnote{schnellere Kompilierung}
  \item \textbf{Ausführung}:\footnote{Programm wird kompiliert \und danach
  gleich ausgeführt} \texttt{scala}
  \item \textbf{Interpreter}: nur \texttt{scala} in Konsole eingeben
\end{itemize}


\subsection{Einfache Programme}
\begin{itemize}
  \item Hello Helex:
  
  \lstinputlisting{examples/hello_helex.scala}
  
  $\Rightarrow$ Datei muss wie das Objekt heißen, damit es ausgeführt werden
  kann
  \item Zahlen:
  
  \lstinputlisting{examples/numbers.scala}
  
  \item ein Programm, dass ein String in Int parsed und dabei alle Zahlen 
  der Eingabe aufsummiert:
  
  \lstinputlisting{examples/input_parsing.scala}
  
  \begin{itemize}
    \item \itbf{Option}:
    \begin{itemize}
      \item \texttt{Option} ist Container, der Null (dann ists 
      \texttt{None}) \oder ein Element dann ists \texttt{Some(theElement)}
      enthält
      \item durch Option verhindert man \texttt{null} Pointer Exceptions
      
      $\Rightarrow$ gut wenn man Business-Logik schreibt und diesen Fall
      nicht in jeder Abfrage, sondern einfach am Ergebnistyp der Funktion
      festlegt\footnote{denke an Adminbill aus pictrs}
      \item Parsing des Strings: sollte eben keine zahl eingegeben
      werden, so wird keine Exception geworfen, sondern die Ausgabe
      einfach auf \texttt{None} gemappt
    \end{itemize}
    \item \itbf{sum}
    \begin{itemize}
      \item in der Methode \texttt{sum} definieren wir keinen return-Wert
      \item \texttt{in} Parameter ist vom Typ 
      \texttt{Seq}\footnote{\texttt{Seq} ist \textit{supertrait} von 
      \texttt{Array, List} \und andere \textit{Collections}}, was ein 
      ein \textit{trait}\footnote{denke Interface aus Java} ist
      \item \texttt{traits}\footnote{traits beheben das Diamanten-Prob. 
      der multiplen Vererbung, da eine Klasse beliebig viele traits haben} 
      können implementierte Methoden beinhalten \und sind am Besten mit 
      mixins aus Ruby zu vergleichen
      \item mit \texttt{flatMap} ruft die Methode \texttt{toInt}
      für jedes Element der Sequenz in \texttt{in} auf
      \item mit $s => toInt(s)$ definieren wir eine anonyme
      Funktion, die einen einzelnen Parameter $s$ nimmt \und diesen
      an die Funktion \texttt{toInt} weitergibt
      \item \texttt{foldLeft}\footnote{kann man gut verwenden, wenn man die 
      Werte einer Sequenz aufsummieren will} nimmt einen einzelnen Parameter als
      \textit{seed} \und und schreibt das Ergebnis der inneren
      Funktion an diesen \textit{seed} zurück. Dabei wird der 
      \textit{seed} solange weiter $\uparrow$, bis alle Elemente der 
      Sequenz durchlaufen wurden
    \end{itemize}
  \end{itemize}
\end{itemize}


\subsection{Warum Skala}
\begin{itemize}
  \item \textbf{Scala ist kompatibel}: Man kann alles
  von Java verwenden
  \item \textbf{Scala ist knapp und präzise}: weniger
  Text bedeutet schnelleres lesen, weniger lesen \und 
  mehr Spaß beim proggen; Scalas \textit{type inference}
  sorgt dafür, dass man manche Typinfos einfach weglassen
  kann
  \item \textbf{Scala ist \textit{high-level}}:
  Komplexität durch Abstraktion senken
  \item \textbf{Scala ist statically typed}: 
  \textit{classifies variables and expressions according
  to the kinds of values they hold and compute}
\end{itemize}
\pagebreak


\section{Eigenschaften zur Sprache}
\begin{itemize}
  \item Wofü Scala geeingnet ist:\textit{language ideal for today’s scalable,
  distributed, component-based applications that support concurrency and
  distribution}
  \item \textbf{Merke}: \textit{Is a statically typed\footnote{der Typ 
  einer Variable ist für die gesamte Lebenszeit der Variable fest}, 
  mixed-paradigm, JVM language with a succinct, elegant, and flexible 
  syntax, a sophisticated type system, and idioms that promote 
  scalability from small, interpreted scripts to large, 
  sophisticated applications.}
  \item Programmiersprachen für Softwarekomponenten müssen \textbf{skalierbar}
  sein $\Rightarrow$ Konzentration bei Scala auf Abstraktion, Komposition
  und Dekomposition
  \item skalierbare Unterstützung für Komponenten kann nur erreicht werden,
  wenn OOP generalisiert und mit funktionalen Aspekten (FP) einer
  Programmiersprache vereinigt werden
  \item Scala arbeitet gut mit Java und C\# zusammen
  \item Typsystem von Scala hat folgende Vorteile:
  \begin{enumerate}
    \item Abstrakte Typdefinitonen und vom Pfad 
    abhängige Typen\footnote{\enquote{\textit{v}Obj calculus}} unterstützen
    \item modulare mixing Komposition
    \item \textit{views}\footnote{ermöglichen Komponenten-Adaption in 
    einem modularen Weg}
  \end{enumerate}
  \item Scala Klassen \und Objekte können von Java-Sachen erben \und Java-
  Interfaces implementieren $\Rightarrow$ man kann Scala-Code in einem 
  Java-Framework\footnote{wicket} verwenden
  \item \textbf{high-order functions}: sind Funktionen, die Funktionen als
  Argumente nehmen \oder Funktionen als Ergebnis zurückliefern \und diese
  werden von Scala unterstützt
  \item \textbf{scope} verschachtelte Funktionen können auf alle Parameter 
  \und lokalen Variablen innerhalb ihrer Umgebung zugreifen
  \item Funktionen-Def mit nur einer Zeile benötigen keine geschweiften Klammern
  \item \textbf{id: type}-Syntax wird von Scala verwendet 
  \item \textbf{unit} wird statt \texttt{void} in Scala verwendet, d.h. es ist der
  void Rückgabetyp
  \item Scala hat eine Darstellung on Javas \texttt{void}, nämlich 
  \texttt{Unit}\footnote{kann man explizit zurückgeben, wenn man einfach
  () beim Returnwert einer Funktion hinschreibt}
  \item alle Kontrollstrukturen von Java sind auch in 
  Scala\footnote{for-Schleifen wurde stark vereinfacht :)} vorhanden
  \item in Scala hat alles einen öffentlichen Zugriff, es sein denn
  es wird anders definiert
  \item \textbf{Klassen mit Argumenten}: Argumente dienen als
  Konstruktoren für die Klasse
  
    \lstinputlisting{examples/klassen_constructor.scala}

  \item Scala-Objekt ist Instanz einer Klasse \und kann deswegen als
  Parameter von Methoden agieren kann
  \item Klassen, Objekte \und \itbf{traits}\footnote{um es in Java-Sprache
  auszudrücken sind \textit{traits} Interfaces mit einer Superklasse, die
  nicht-abstrakte Methoden beinhalten dürfen} können innere Klassen, Objekte
  \und traits haben, welche Zugriff auf \textit{private} Methoden,
  Variablen und so weiter haben
  \item die Import-Methode kann innerhalb von Blöcken verwendet werden
  $\Rightarrow$ können dadurch feingranular den scope festlegen
  \item Scala ist statisch typisiert
  \item \textbf{Nothing}: eine Methode mit diesen Rückgabewert, wird
  normalerweise niemals laufen
  \item \textbf{Any} ist die Mutter aller Klassen in Scala
  \item \textbf{AnyRef} bedeutet dasselbe wie Javas \texttt{Object},
  jedoch mit den Unterschied, dass mit == die inhaltliche Gleichheit von 
  Objekten gemeint ist - will man die Referenz von Objekten beurteilen,
  dann nimmt man lieber die Methode \texttt{eq}
  \item der return-Wert von Funktionen ist per default die letzte Zeile einer
  Methode\footnote{man kann aber auch explizit return angeben}
  \item \textbf{call-by name} kann man in Scala durch $=>$ für Funktionsaufrufe 
  anfordern:
  
  \lstinputlisting{examples/call_by_name.scala}
  
  $\Rightarrow$ es kommen verschiedene Zeiten heraus $\Rightarrow$ in
  \textit{delayed} wird bereits reingegangen bevor \textit{nano} 
  aufgerufen wird und somit wird \textit{nano} zweimal aufgerufen
  \item \texttt{[B $>:$ T]} heißt, dass \texttt{B} mindestens von derselben
  Klasse wie \texttt{T}
  \item \textbf{impliziten Konversion}: man fügt einer eigentlichen als 
  \texttt{final} deklarierten Klasse noch
  zusätzliche Methoden hinzu\footnote{einfach implicit vor Methodendef
  schreiben}
  
  \lstinputlisting{examples/implizit.scala}
  
  hier wird als \texttt{Int} nach \texttt{Rational} konvertiert
  
  \item Scala ist FP, d.h. in dem Sinne, dass jede Funktion einen Wert hat
  \item Scala ist statisch Typisiert \und das Typsystem unterstützt:
  \begin{itemize}
    \item \textbf{generische Klassen}
    \item \textbf{Varianz}-Annotationen
    \item obere \und untere Schranken für Typen
    \item \itbf{compound types}
    \item polymorphe Methoden
    \item Scala ist erweiterbar: man kann leicht neue Sprachkonstrukte
    zur Sprache ergänzen
  \end{itemize}
  \item Scala kompiliert in normalen Java Bytecode
  \item Scala arbeitet gut mit Java \und .NET an
  \item jede Java Klasse kann als eine normale Scala-Klasse verwendet werden
  $\Rightarrow$ deswegen sind alle Java-Bibos auch direkt in Scala verwendbar
  \item gewöhnlicher Java-Code ist kein valider Scala-Code, aber wenn der
  Java-Code einmal kompiliert wurde, dann kann er vom Scala-Code verwendet
  werden
  \item Scala behandelt das auftauchen von Bezeichnern zwischen zwei
  Ausdrücken als Methodenaufruf
  \item Scala läuft wie Java auf derselben JVM \und sie teilen sich deshalb
  den gleichen Garbage-Collector
  \begin{itemize}
    \item auf Java Bytecode kann Scala:
    \begin{itemize}
      \item Objekte instanziieren
      \item Methoden aufrufen
      \item exceptions werfen/abfangen
      \item Klassen erweitern
      \item Interfaces implementieren
    \end{itemize}    
    \item Java-Klassen als Mixins, wenn diese als Quellcode vorhanden
    sind
    \item Java \enquote{locking \und concurency model} wird unterstützt, wird
    aber normalerweise von Scala gerwapped
  \end{itemize}
  \item Imports sind wie in Java, nur mit mehr Features (denke ans
  Alias) \und imports können allen Stellen des Programms gemacht werden
  \item wenn Typen offensichtlich sind, dann muss man diese nicht angeben, kann
  aber zu bösen Fehlern führen
  \item Generics\footnote{statt Generics sagt man in Scala zu 
  dynamischen Datentypen von Funktionen \itbf{parameterized types}}:
  \begin{itemize}
    \item Klassen \und traits können generisch gemacht werden
    \item via \itbf{Typparameter} (Nonvariant, Covariant, Contravariant)
    \item obere \und untere Schranken
  \end{itemize}
  \item Scala erlaubt die Definition von parameterlosen Methoden \und jedesmal
  wird so eine Funktion aufgerufen, wenn dessen Name verwendet wird
  \item FP Eigenschaften: \textit{Higher-order functions}; 
  \textit{Function closure support}; Rekursion als \textit{flow control}; 
  \textit{pure Funktionen} $\Rightarrow$ keine 
  Seiteneffekte\footnote{viele Datenstrukturen sind immutable, mit 
  \texttt{val} sind immutable \und mit \texttt{var} sind mutable};
  \textit{Pattern Matching}
  \item immutable \texttt{val} müssen initialisiert werden!  
  \item Klassen können überall in einem Programm auftauchen: top-level,
  innerhalb von anderen Klassen (\textit{inner classes}), innerhalb von
  Codeblöcken (\textit{local classes}) \und innerhalb von Ausdrücken 
  (\textit{anonymous classes}) $\Rightarrow$ analog gilt das für Funktionen
  in Scala, nur das Funktionen nicht als Top-Level deklariert werden können
  \item Scala ist eine stark typisierte Sprache: \textit{class types},
  \textit{variant class type parameters}, \textit{virtual types}, 
  \textit{qualified class types},  \textit{compound types}\footnote{kann
  man festlegen, dass ein Wert eine Instanz von einer Liste von Klassen
  ist}, \textit{singleton types}\footnote{für Typen gibt es genau einen
  Wert}, \textit{explicit self types}\footnote{sind Annotationen, die den Typ 
  einer aktuellen Instanz einer Klasse festlegen}
  \item Scala unterstützt \itbf{Symbole} aus Ruby
  \item \texttt{null} gibts in Scala, aber ab in die Tonne damit \und 
  besser \texttt{Option} verwenden
  \item wenn man \textbf{final} vor Klassen \oder traits schreibt, dann
  verhindert man, dass davon Klassen abgeleitet werden können
  \item \textbf{super} ist analog zu this, aber es bindet an die Elternklasse
  \item \textbf{this} wie ein Objekt auf sich alleine zeigt
  \item das \$ verwendet Scala intern für irgendwas, also ebenso wie
  die keywords nicht als Variablennamen verwenden
  \item Scala-Konvention: Klammern bei Methodenaufrufen vermeiden, wenn
  diese keine Seiteneffekte verursachen
  \item \itbf{Generatoren}:
  
  \lstinputlisting{examples/generators.scala}
  
  der \textit{left-arrow} Operator wird eben Generator genannt, der er die
  einzelnen Elemente aus der Collection generiert
  \item der $=>$ Operator gibt an, dass aktuelle Argumente für diesen Parameter
  unausgewertet übergeben werden.
    
  die Argumente einer solchen Funktion werden jedesmal ausgewertet, wenn der
  formale Parameter erwähnt wird
  
    \lstinputlisting{examples/unausgewertete_parameter_uebergabe.scala}
  \item die Behandlung von Variablenzugriffen als Methodenaufrufen ermögicht
  es in Scala \textbf{properties} zu definieren. Im folgenden Beispiel wird
  die Eigenschaft \textit{degree} definiert, welche nur einen Wert entspricht,
  der größer \oder gleich -273 ist
  
  \lstinputlisting{examples/properties.scala}
  \item für jede Variable \textbf{var} \textit{x: T} definiert Scala
  die folgenden \textit{setter} und \textit{getter} Methoden:
  
  \lstinputlisting{examples/getter_setter.scala}
  
  diese Methoden referenzieren und updaten die entsprechende Speicherzelle für
  die Variable, welche nicht direkt durch Scala-Programme beeinflussbar ist
  \item Kommentare:
\lstinputlisting{examples/comments.scala}
  \item \textbf{def} wird zur Festlegung von Funktionen verwendet
  \item \textbf{Array Typen} werden Array[T] geschrieben \und 
  \textbf{Array-Zugriffe} werden mit a(i) statt a[i] geschrieben
  \item Scala unterscheidet nicht zwischen Identifier \und Operatorennamen,
  d.h. \texttt{xs filter (pivot $>$)} ist äquivalent zu 
  \texttt{xs.filter(pivot $>$)}
  \item alle Funktionen haben die \texttt{apply}-Methode, welche die 
  Funktion ausführen
  \item \textbf{Option[T]}
  \begin{itemize}
    \item ist Alternative zu Javas \texttt{null}
    \item \texttt{Option} hat nur die Werte \texttt{Some[T]} \oder 
    \texttt{None} haben
    \item \texttt{None} ist ein Objekt \und in einem Scala Programm gibt es
    nur eine Instanz von \texttt{None}
  \end{itemize}
  \item alle \texttt{AnyVal} Instanzen sind immutable \und alle 
  \texttt{Anyvalue} Typen sind \textit{abstract final}
  \item \uline{Nerdwissen}:
  \begin{itemize}
    \item das sogenannte \textbf{Predef Objekt} lädt automatisch
    wichtige Sachen in ein Scala Programm
    \item Objekte werden automatisch und \textit{lazy} zur Laufzeit
    instanziiert
    \item Typahierachieübersicht siehe Odersky-Paper
  \end{itemize}
  
  \item \ulbf{Typem Bounds}

  \begin{itemize}
    \item \texttt{A $<:$ AnyRef} means any type \texttt{A} that is a 
    subtype of \texttt{AnyRef}
    \item bla, wurde an anderer Stelle besser erklärt
  \end{itemize}


  \item \ulbf{Nothing und Null}

  \begin{itemize}
    \item \texttt{Null} ist \texttt{final trait} \und kann nur eine 
    Instanz haben
    \item \texttt{Nothing} ist \texttt{final trait} \und hat keine Instanz
  \end{itemize}

  \item \itbf{Views}\footnote{\textit{implicit conversions between
  types}; sie werden typischerweise angelegt, um neue Funktionalitäten
  für einen davorexistierenden Typ zu ergänzen}? Was ist im selben 
  Zusammehang der 
  \item \textbf{implizit} Parameter\footnote{Argumente hierfür können 
  bei einem Methodenaufruf weggelassen werden}?
  \item Unterschied zwischen val \und var?
  \begin{itemize}
    \item Variablen können in Scala jeweils den Wert 
    \textit{assign-once} \oder \textit{asign-many} haben
    \item \textit{assign-once}: mit \texttt{val} (ähnlich final
    in Java)
    \item \textit{assign-many}: mit \texttt{var}
    
    $\Rightarrow$ am besten immer val verwenden, denn je weniger
    sich Dinge $\Delta$ können, desto weniger Fehler können sich
    in den Code schleichen
  \end{itemize}
  
  \item Unterschied zwischen \texttt{def x = e} \und \texttt{val x = e}:
  \begin{itemize}
    \item \texttt{def} - hier wird \texttt{e} nicht ausgewertet, sondern erst,
    wenn \texttt{x} verwendet wird
    \item \texttt{val} - hier wird \texttt{e} sofort 
    ausgewertet\footnote{sobald man \texttt{x} verwendet, ist der Ausdruck 
    \texttt{e} bereits vorhanden}
  \end{itemize}
  \item \ulab{Frage}: Wie werden Ausdrücke ausgewertet? \begin{itemize}
    \item schnappe die die am meisten links stehende Operation
    \item werte die Operanden aus
    \item verwende die Operation entsprechend mit den Werten der Operanden
  \end{itemize}
  \item neue Typen können insofern verwendet werden,
  indem diese Typen als \textit{buil-ins} eingebunden
  werden
  \item die $++$ \und $--$ Ops aus Java gibts es in Scala nicht
  \item \texttt{max} Methode ermittelt von zwei Objekten das
  Maximum: \texttt{3.max(2)}
  \item jeder Basis-Typ hat einen sogenannten \textbf{Rich wrapper}, der
  zusätzliche Methoden bereitstellt:
  
  \begin{verbatim}
  String hat scala.runtime.RichString
  \end{verbatim}
  
  $\Rightarrow$ genauso funzen auch die anderen Typen
  
  \item trait mit den Namen \texttt{Ordered} implementiert die folgende
  Ops $<=, >=, <, >$ \und macht sich gut, wenn man bestimmte Werte
  ergänzen möchte
  
  \lstinputlisting{examples/trait_ordered.scala}
  
\end{itemize}


\subsection{Paradigmen}
\ulbf{\kreis{1. } OOP-Paradigma}


\begin{itemize}
  \item alles ist ein Objekt
  \item Scala hat die typischen Mechanismen von OOP, aber ergänzt das ganze
  noch durch \textit{traits}, \textit{mixin composition}
  \item es gibt keine primitven Datentypen wie in Java, anstelle sind alle 
  numerischen Typen Objekte
  \item Scala unterstützt \textit{singleton object construct}
\end{itemize}


\ulbf{\kreis{2. }FP-Paradigma}


\begin{itemize}
  \item FP sind gut für Design-Probs wie \textit{concurrency}, da pure FP
  keine $\Delta$ Zustände erlaubt\footnote{um Synchronisation muss man
  sich nicht kümmern}
  \item in puren FP kommunizieren Programme durch den Autausch von
  nebenläufigen autonomen Prozessen $\Rightarrow$ Scala unterstützt dass
  durch seine \texttt{Actors Library}, aber es unterstützt auch
  veränderliche Elemente, wenn man das will
  \item Funktionen sind \itbf{first class}\footnote{d.h. sie können 
  an Variablen, an andere Funktionen usw. ähnlich wie Werte übergeben werden}
  \und Scala bietet \itbf{closures}\footnote{bezeichnet man 
  eine Programmfunktion, die beim Aufruf einen Teil ihres vorherigen
  Aufrufkontexts reproduziert, selbst wenn dieser Kontext außerhalb der 
  Funktion schon nicht mehr existiert $\Rightarrow$ sind ein mächtiges 
  Werkzeug zur Abstraktion} 
\end{itemize}


\ulbf{\kreis{3. } Skalierbarkeit}\footnote{es wurde designt, um von kleinen, interpretierten
Skripten zu großen, verteilten Anwendungen zu skalieren} wird durch folgende
Sachen gewährleistet:


\begin{enumerate}
  \item explizite \textit{self types}
  \item abstrakte \textit{type members} \und \textit{generics}
  \item verschachtelte Klassen
  \item \textit{mixin} Komposition durch Verwendung von \textit{traits}
\end{enumerate}


\ulbf{\kreis{4. }Performanz}


\begin{itemize}
  \item da Scala ja auf der JVM läuft, unterstützt auch die ganzen dafür
  entwickelten Optimierungsmethoden (Profilers, verteilter Cache, Clustering)
\end{itemize}


\subsection{Operationen sind Objekte}
\ulbf{Methoden sind funktionale Werte}


\begin{itemize}
  \item betrachten die folgende Funktion, welche überprüft, ob ein Array eine
  Element mit einer bestimmten Eigenschaft (Prädikat) hat:
  
  \lstinputlisting{examples/array.scala}
  
  \begin{itemize}
    \item der Elementtyp des Arrays ist beliebig, wird durch den Parameter [T]
    angegeben der exists-Methode angegeben 
    \item die zu testende Eigenschaft ist beliebig \und dies wird durch
    den Parameter $p$ der exists-Methode repräsentiert
    \item der Typ von \texttt{p} ist der \textit{Funktionstyp} $T => boolean$,
    welche als Werte alle Funktionen mit der Domäne $T$ und den Bereich von
    $boolean$ hat
    \item Funktionsparameter können wie normale Funktionen angewendet werden 
    (siehe im $p$ in while-Schleife)
    \item mithilfe der obigen Funktion können wir eine Funktion \texttt{forall}
  via Doppelnegation erstellen: Ein Prädikat gilt für alle Elemente eines Arrays,
  wenn es kein Argument gibt, dass nicht die Eigenschaft des Prädikats erfüllt
    \begin{itemize}
      \item \texttt{forall} definiert eine \textbf{geschachtelte Funktion} 
      $not\_p$, welche den Parameter $p$ negiert
      \item \texttt{forallAnonymous}: hier definiert $(x: T) => !p(x)$
      ein anonyme Funktion, die alle Parameter vom Typ $T$ nach $!p(x)$
    \end{itemize}
  \end{itemize}
  \item wenn Methoden Werte sind \und Werte Objekte, dann folgt, dass Methoden
  selbst Werte sind
\end{itemize}


\ulbf{Funktionen verfeinern}


\begin{itemize}
  \item da FunktionsTypen in Scala Klassen sind, kann man Sie in Unterklassen
  weiter verfeinern
  \item Klasse \texttt{Array[T]} erbt von der Funktion \texttt{Function1[int, T]}
  \und fügt Methoden für Array-Update, Array-Länge usw. hinzu
  
  \lstinputlisting{examples/refining_functions.scala}
\end{itemize}


\subsection{Varablendeklarationen}
\begin{itemize}
  \item werde wie Methoden definiert beginne aber mit einen der folgenden
  \textit{keywords}:
  
  \begin{Beschreibungfett}[lazy val]
    \item [var] können ihren Wert $\Delta$ (genauso wie Variablen in Java)
    \item [val] definiert nur Werte $\Rightarrow$ \textit{read only}
    \item [lazy val] wird erst dann zugewiesen, wenn die Variable
    verwendet wird 
  \end{Beschreibungfett}  

\end{itemize}


\subsection{if/else, while und do-while}
\begin{itemize}
  \item if/else wird eher selten verwendet \und verhalten sich eher wie
  der Ternary-Operator; while-Schleifen sind ebenso effizient wie 
  Rekursion\footnote{beachte hierbei die \textit{tail-rekursion} bei
  funktionalen Sprachen}
  
  \lstinputlisting{examples/if_else_ternary_while_do_while.scala}
  
  \item das Ergebnis von if \und while ist immer \texttt{Unit}, sofern man nichts
  anders angibt
\end{itemize}


\subsection{for-Schleife}
\begin{itemize}
  \item einfache Variante ist wie in Java:
  
  \lstinputlisting{examples/for_easy.scala}
  
  \item verschachtelte Variante:
  
  \lstinputlisting{examples/for_middle.scala}
  
  \item in for-Schleifen kann man auch guards packen:
  
  \lstinputlisting{examples/for_guards.scala}
\end{itemize}


\subsection{yield}
\begin{itemize}
  \item wird als Platzhalter für Berechnungen einer Liste genommen, in der
  die Ergebnisse in der \texttt{yield}-Variable abgelegt werden \und anschließend
  an die Liste zurückgegeben werden, die aufgerufen wurde
  
  \lstinputlisting{examples/yield.scala}
 
\end{itemize}


\subsection{foreach}
\begin{itemize}
  \item ist die bessere \und eher funktionale Variante 
  
  \lstinputlisting{examples/foreach.scala}
\end{itemize}


\subsection{try-catch, throw und finally}
\begin{itemize}
  \item throws bzw. try/finally funzt wie in Java:
  
  \lstinputlisting{examples/throw_try_finally.scala}
  
  \item try/catch ist anders:
  \begin{itemize}
    \item es gibt immer ein einen Wert zurück
    \item es weist einen default Wert zu, sobald alle anderen Tests
    durchgefallen sind
    
    \lstinputlisting{examples/try_finally.scala}
    
  \end{itemize}
  \item \texttt{finally} clause wird immer ausgeführt, unabhängig davon,
  wie das Programm beendet wird:
  
  \lstinputlisting{examples/finally.scala}
  
\end{itemize}


\subsection{Enumerations}
Einfach Klassen von \texttt{Enumeration} erben lassen \und es ist dann
keine besondere Notation für die Elemente der Aufzählung nötig

\lstinputlisting{examples/enumeration.scala}


\subsection{Linearisierung der Objekthierarchie}
betrachte folgendes Bsp.:

\lstinputlisting{examples/linearization_object_hierarchiy.scala}


hier ist der Linearisierungsalgo, den Scala verwendet:

\begin{enumerate}
  \item Put the actual type of the instance as the first element.
  \item Starting with the rightmost parent type and working left, compute the linearization
of each type, appending its linearization to the cumulative linearization. (Ignore
ScalaObject, AnyRef, and Any for now.)
  \item Working from left to right, remove any type if it appears again to the right of the
current position.
  \item Append ScalaObject, AnyRef, and Any.
\end{enumerate}
\pagebreak


\section{Funktionen}
\begin{itemize}
  \item FKt. sind in Scala eine Instanz von Klassen:
  
  \lstinputlisting{examples/functions.scala}
  
  \item \textbf{Funktionen als Parameter übergeben}:
  
  definieren eine Methode w42, die eine Funktion als Parameter übernimmt:
  
  \lstinputlisting{examples/function_as_parameter.scala}

  \item Funktionen können in Scala Symbole wie $+, -, *, and, ?$ enthalten
  $\Rightarrow$ sind sogenannte Varianzparameter
  \item Funktionen können die folgende Form
  haben: \texttt{Function[A, B]}, wobei \texttt{A} der Parametertyp 
  \und \texttt{B} der Rückgabewert ist
  
  $\Rightarrow$ andere Schreibweise für \texttt{Function[A, B]}:
  
  \begin{center}
    \texttt{A $=>$ B}
  \end{center}
    
  \item Funktionen, welche andere Funktionen als Parameter nehmen werden
  \textit{high-order} Funktionen genannt
    \item falls man eine Variable Liste an Parametern haben möchte, dann muss *
  in die Parameterliste einer Funktionsdef setzen:
  
\lstinputlisting{examples/method_declaration_4.scala}
    
  \item man kann auch Schranken für Typen definieren. Im folgenden Beispiel 
  müssen alle Typen vom Typ \texttt{Number} \oder von einer Subklasse von
  \texttt{Number} sein:
  
  \lstinputlisting{examples/method_declaration_6.scala}

\end{itemize}


\subsection{Parameter}
\begin{itemize}
  \item Funktionsparameter werden immer von Klammern eingeschlossen
  
  \begin{Beschreibungfett}[call-by-value]
    \item [call-by-value] Vorteil ist Vermeidung der wiederholten Auswertung 
    von Argumenten
    \item [call-by-name] hat den Vorteil, dass es die Parameter nicht 
    auswertet, sofern sie nicht in der Funktion verwendet werden
  \end{Beschreibungfett}
  
  call-by-value ist effizienter als call-by-name, aber call-by-value
  kann in $\infty$-loops geraten
    
  \item Scala benutzt per Def. call-by-value, aber kann auf call-by-name
  wechseln durch Voranstellung von $=>$:
  
  \lstinputlisting{examples/comparison_call_by_value_call_by_name.scala}
  
\end{itemize}


\subsection{Typparameter}
\begin{itemize}
  \item Typparameter definieren den Typ von Parametern \oder den
  Rückgabewert der Fkt.:

  \lstinputlisting{examples/typparameter_functions.scala}
\end{itemize}


\subsection{Verschachtelte Funktionen und Parameter}
\begin{itemize}
  \item wird auch als \textit{enclosing function bezeichnet}, d.h. durch
  Schachtelung von Funktionen können Helper-Funktionen auf die Parameter ihrer
  Elternfunktionen zurückgreifen
  \item \lstinputlisting{examples/nested_functions.scala}
  
  fact kann man nur innerhalb des Scopes von factorial aufrufen, sonst kommt
  es zu einem Compilerfehler.
  
  \item weitergabe von Parametern innerhalb verschachtelten Funktionen:
  
  \lstinputlisting{examples/parameter_passing_nested_functions.scala}  

\end{itemize}


\subsection{Wiederholende Parameter}
\begin{itemize}
  \item in die Argumentenliste einer Funktion packt man einfach ein 
  \textit{asterisk}
  
  \lstinputlisting{examples/repeated_parameters_with_asterisks.scala}
  
  \texttt{String*} ist shortcut für \texttt{Array[String]}  
\end{itemize}


\subsection{First-Class Funktionen}
\begin{itemize}
  \item d.h. man kann Fkt. in Funktionsliteralen
  darstellen
  
  \lstinputlisting{examples/first_class_functions.scala}

  \item man kann durch sogenanntes \textit{taget typing} die
  Schreibweise von oben verkürzen:
  
  \lstinputlisting{examples/function_literals_short.scala}
  
  der Compiler weiss, dass der Filter auf eine Liste von Integern
  angewendet wird \und deswegen werden die entsprechenden Typen
  weggelassen \und der Code wird übersichtlicher
  
  \item \textbf{Placeholder Syntax}: man kann Underscores als 
  Platzhalter für die Variablen verwenden $\Rightarrow$ dadurch
  wird die Notation noch kürzer
  
  \lstinputlisting{examples/function_literals_placeholder_syntax.scala}
  
  man kann sich den Underscore als Blank vorstellen, der ausgefüllt
  werden muss
  
\end{itemize}


\subsection{Partielle Funktionen}
\begin{itemize}
  \item \textbf{in Scala ist alles bis auf Methoden eine 
  Instanz}\footnote{Methoden sind keine Funktionen in Scala}
  \item Methoden werden an Instanzen angehangen \und angewendet
  \item in Scala können wir partiell angehauchte Funktionen von Methoden
  her ableiten:
  
  \lstinputlisting{examples/partial_functions.scala}
  
  \texttt{p} braucht einen zweiten Parameter, um die Anforderungen an
  die Funktion plus 42 zu erfüllen \und wir sagen \texttt{p} ist
  partielle Anwendung von \texttt{plus}
  
  \item partielle Methodendefs können mit der folgenden Syntax besser
  beschrieben werden:
  
  \lstinputlisting{examples/partial_notation.scala}
  
  
  durch diese Notation kann man Codeblöcke als Parameter übergeben:
  
  \lstinputlisting{examples/partial_codeblocks.scala}
  
    \item wenn an eine Funktion ein Unterstrich übergeben wird, dann handelt
  es sich um eine partielle Funktionen
  \item partielle Funktionen sind Aurücke, in denen nicht alle Argumente 
  einer Funktion auch von der Funktion übernommen werden
  
  \lstinputlisting{examples/partial_functions_easy.scala}
  
  lässt man hinter den Funktionsaufruf ein Leerzeichen
  \und setzt einen Underscore, so ist dieser der Platzhalter
  für alle Parameter in der Funktionsliste
  
  $\Rightarrow$ beim Aufruf kann man sich dann ausuchen,
  wie viele Parameter man der Funktion dann übergeben
  will
\end{itemize}


\subsection{Funktionen in Container}
\begin{itemize}
  \item Funktionen sind Instanzen \und deswegen kann man alles, was man
  mit Instanzen machen kann auch mit Funktionen machen
  \item Array von Funktionen\footnote{erinnert frappierend an
  Wörterbuch der Algorithmen}:
  
  \lstinputlisting{examples/function_container.scala}
    
\end{itemize}


\subsubsection{Callback}
Fkt. mit callback Fkt. haben folgende Syntax: 
  \textsc{() =$>$ Unit} und ist eine Funktion, die keine Parameter \und 
  kein return-Wert hat
  
  \lstinputlisting{examples/callback.scala}


\subsubsection{Anonyme Funktionen}
\begin{itemize}
  \item doof, wenn man Funktionen einen Namen geben muss, wenn man sie
  nur einmal verwenden $\Rightarrow$ hierfür sind anonyme Funktionen da :)
  \item die Anwesenheit von anonymen Funktion wird durch die Syntax:
  \textsc{=$>$} gemacht
  
  \lstinputlisting{examples/callback_anonymous.scala}
\end{itemize}


\subsection{Closures}
\begin{itemize}
  \item der Name stammt daher, dass die Funktion durch Bindung der freien
  Variablen an seinen Rumpf entsteht:
  
  \lstinputlisting{examples/closure.scala}
  
  \item eine Funktion ohne freie Variablen wird \textit{closed term} genannt
  \item was passiert nun, wenn die freien Variablen geändert werden,
  wenn das Closure schon angelegt werden? Scala erkennt den Kontext \und 
  passt sich an die Änderung der freien Variable an
\end{itemize}


\subsection{Generische Typen und Methoden}
\begin{itemize}
  \item haben einen Stack für Integer
  
  \lstinputlisting{examples/stack_integer.scala}
  
  \item diesen Stack durch \textbf{Typen Parameter} ganz leicht generisch machen
  
  \lstinputlisting{examples/stack_generisch.scala}
  
  \item dasselbe Prinzip kann man auch bei Methoden anwenden \und generische
  Methoden sind auch ein Ausdruck von Polymorphi:
  
  \lstinputlisting{examples/generische_funktionen.scala}
\end{itemize}


\subsection{Schwanzrekursion}
\lstinputlisting{examples/gcd.scala}


\lstinputlisting{examples/factorial.scala}


\begin{itemize}
  \item gcd hat immer dieselbe Form, während bei factorial immer noch ein
  multiplikativer Faktor hinkommt
  \item bei Faktorial werden für die Multiplikatoren stets ein neuer
  Stack-Frame angelegt \und es braucht deshalb Platz proportional der
  Eingabe $\Rightarrow$ ist deswegen keine Schwanzrekursion
  
  $\Rightarrow$ im folgenden Code wird nun gezeigt, wie man Schwanzrekursion
  erzeugen kann:
  
  \lstinputlisting{examples/nested_functions.scala}
\end{itemize}
\pagebreak


\section{FP in Scala}


\subsection{Was FP ist}
\begin{itemize}
  \item haben keine Seiteneffekte, d.h. Analyse, Testen \und debuggen
  werden leichter
  \item Variablen sind in FP immutable
  \item \textit{referential transparency}\footnote{d.h. man kann eine
  Funktion in jeden beliebigen Kontext aufrufen \und muss keine Sorgen 
  um den Kontext machen in dem die Funktion aufgerufen wird}
\end{itemize}


\subsection{FP in Scala}
\begin{itemize}
  \item \ulab{Merke}: eine Funktion, die \texttt{Unit} zurückgibt,
  hat pure Seiteneffekte, denn ansonsten ist die Funktion sinnlos,
  da sie ja nichts zurückgibt
  
  \lstinputlisting{examples/fp_list_map.scala}
  
  \item anonyme Fkt. auch auf ein val drücken:
  
  \lstinputlisting{examples/fp_list_map_value.scala}
  
  $\Rightarrow$ \texttt{factor} ist kein formaler Parameter sondern eine
  Referenz zu einer Variable in einen bestimmten \textit{scope}, d.h. 
  der Compiler kreiert ein \textit{closure}
  \item \textbf{Rekursion}:
  
  \begin{itemize}
    \item verhindert mutable Variablen
    \item aber Performanz-Overheadn \und Risiko des Stackoverflows
    \item Performaz-Prosb können mit \textit{memorization} \und 
    Stackoverflows können durch Umwandlung in eine spezielle 
    Schleife (Tail Calls \und Tail-Call Optimierung) verbessert
    werden
  \end{itemize}
\end{itemize}


\subsection{Tail Calls}
Tail Call, d.h. wenn eine Funktion sich erst bei ihren
finalen Durchlauf selbst aufruft $\Rightarrow$ Schleifen verhindern die
Gefahr eines Stackoverflows:

  \lstinputlisting{examples/factorial_recursive_and_tail_call.scala}


\subsection{Funktionale Datenstrukturen}
\begin{itemize}
  \item \textbf{Listen}: tauchen ganz oft in FP auf
  
  \lstinputlisting{examples/lists_fp.scala}
  
  \item \textbf{hash/dictionary/map}
    
  \item \textbf{Mengen}: sind wie Listen, aber ihnen kann jedes
  Element nur einmal vorkommen; Element Iteration geht in O(n)
\end{itemize}


\subsection{Listen}
\begin{itemize}
  \item Listen in Scala unterscheiden sich folgendermaßen von
  anderen Sprachen: \begin{enumerate}
    \item sind unver-$\Delta$ \und dessen Elemente müssen immer
    vom selben Typ sein (was bei Arrays nicht der Fall sein
    muss)
    \item haben rek. Struktur
    \item haben viel mehr Ops. als Arrays
  \end{enumerate}
  
  \lstinputlisting{examples/listen.scala}
  
  \item Vorteile Unver-$\Delta$:
  \begin{itemize}
    \item weniger globale Zustände $\Rightarrow$ weniger Dinge
    können sich $\Delta$
    \item Fkt. werden weniger anfällig für globale Zustände von
    Variablen 
    \und Funktionen werden mehr transformativ $\Rightarrow$ Methoden
    referenzieren viel weniger auf den externen Zustand von
    Variablen
    \item solche Methoden sind leichter mit automatischen 
    Tests\footnote{\texttt{ScalaCheck}} durchzuführen
  \end{itemize}
\end{itemize}


\subsubsection{List[T]}
\begin{itemize}
  \item List[T] ist eine verkettete Liste vom 
  Typ T\footnote{ist also verkettet} $\Rightarrow$ ist sequentielle
  Liste, welche Javas primitve Datentypen beinhaltet 
  (\texttt{Int, Float, Double}), da sich um 
  \textbf{boxing}\footnote{also Umwandlung von primitiven
  Datentypen in Objekten} kümmert
  \item \textbf{Listen-Konstruktoren}: \texttt{Nil} ist
  Repräsentant für eine leere Liste, \texttt{::} (cons genannt)
  \uline{z.B.} 
  \texttt{x :: xs} $\Rightarrow$ Liste mit ersten Element \texttt{x}
  und zweiten Element/Liste \texttt{xs}
  
  \lstinputlisting{examples/cons.scala}
  
  $\Rightarrow$ mit \texttt{Nil} drücken wir die leere Liste aus
  \item \textbf{Listen sind homogen}\footnote{d.h. innerhalb einer
  Liste müssen alle Elemente vom selben Typ sein}:
  
  \lstinputlisting{examples/listen_1.scala}
  
  \item \textbf{Item an Liste dranhängen}:
  
  \lstinputlisting{examples/collection_append.scala}
  
  die alte Variable x bleibt unverändert und an die neue Liste mit
  den Wert 99 als head wird alte Liste x 
  drangehangen\footnote{läuft in O(1)}
  \item \textbf{Listen mergen}: via \texttt{:::}
  
  \lstinputlisting{examples/collection_mergen.scala}
  
  \item \textbf{typische Listen-Ops}:
  
  \lstinputlisting{examples/collection_ops.scala}
  
  \item \texttt{filter} funzt bei jeder Collection, welche einen
  bestimmten Typ enthält:
  
  \lstinputlisting{examples/collection_universel.scala}
  
  $\Rightarrow$ konvertieren einen String in \texttt{List[Char]} \und 
  filtern via Methode aus Java aus dieser Char-Liste die Zahlen heraus
\end{itemize}


\subsubsection{Transformation}
\begin{itemize}
  \item \texttt{map} transformiert alle Elemente einer Collection
  basierend auf eine Funktion:
  
  \lstinputlisting{examples/collection_transformation_map.scala}
  
  
  mit Listen kann man komplexe DB-Queries machen
  \und Elemente in Liste ausgeben:
  
  \lstinputlisting{examples/collection_db_query.scala}
  
  \item \texttt{List} hat \texttt{sort}-Methode:
  
  \lstinputlisting{examples/collection_sort.scala}
  
  \item \texttt{reduceLeft}: Operation auf adjazenten Elemente einer
  Collection rekursiv durchführen bis alles abgegrast ist:
  
  \lstinputlisting{examples/collection_reduce_left.scala}
  
  \item \texttt{foldLeft} arbeitet wie \texttt{reduceLeft}, nur dass es 
  einen \textit{Seed} als Startpunkt nimmt, wobei der Seed-Typ den Rückgabewert von \texttt{foldLeft} ist:
  
  \lstinputlisting{examples/collection_foldLeft.scala}
  
  \item geschachtelten Collection erstellen:
  
  \lstinputlisting{examples/collection_nested.scala}
  
  wollen wir die Ergebnisse einer geschachtelten Schleife 
  \enquote{platten}, so \texttt{flatMap}-Methode verwenden
  
  \item \textbf{for-Comprehension}\footnote{for-Comprehension ist 
  kein Schleifenkonstrukt sondern syntaktische Vereinfachung}
  \begin{itemize}
    \item angenommen haben Liste von Personen mit \texttt{namen} \und 
    \texttt{age} \und wir wollem die Namen aller Personen ausgeben, die
    alle über 20 sind
    
    \lstinputlisting{examples/for_comprehension.scala}
    
    \item genereller Aufbau von for-comprehension:
    
    \begin{shadowminipage}
    \lstinputlisting{examples/for_comprehension_generell.scala}
    \end{shadowminipage}
    
    
    s $\ldots$ ist eine Sequenz von \textit{Generatoren, Definitionen}
    \und \textit{Filtern}
    \item ein \textit{Generator} hat die Form 
    \texttt{\textbf{val} x $<-$ e}, wobei
    \texttt{e} eine Liste mit Werten ist \und an \texttt{x} 
    werden sukzessiv die Elemente aus \texttt{e} gehangen
    \texttt{x} ist ein Name für die Werte von \texttt{e}
    \item ein \textit{Filter} ist ein Ausdruck \texttt{f} vom 
    booleschen Typ
    \item angenommen wir wollen das Produkt der Zahlen von 1 bis 10
    zwischen den geraden \und ungeraden Zahlen bilden:
    
    \lstinputlisting{examples/collection_for_comprehesion.scala}
 
  \end{itemize}
\end{itemize}


\subsubsection{Tupel}
\begin{itemize}
  \item sind wie Listen unver-$\Delta$ und können aber im Vergleich
  zu Listen verschiedene Elemente haben
  \item wollen Fkt. schreiben, die 3 return-Werte hat:
  
  \lstinputlisting{examples/tupel_example.scala}
  
  \begin{itemize}
    \item der Compiler übersetzt \texttt{(Int, Double, Double)} in
    \texttt{Tuple3[Int, Double, Double]}
    \item \texttt{foldLeft} hat zwei Parameter: t $\ldots$ steht für 
    Tuple3[Int, Double, Double]
    \item der Rückgabewert der Funktion ist ein neues Tupel
  \end{itemize}
  \item man kann Tupel auf viele verschiedene Arten anlegen:
  
  \lstinputlisting{examples/tupel_creation.scala}
  
  \item um auf Elemente von Tuppeln zuzugreifen verwendet man
  \texttt{t.\_N}, wobei N für das gewünschte Element steht
  \item ein anderes Beispiel mit der \texttt{tupleator} Methode, die aus den
  Argumenten ein Tupel entsprechend der Anzahl der Argumente generiert
  
  \lstinputlisting{examples/tupleator.scala}
\end{itemize}


\subsubsection{Map[K,V]}
\begin{itemize}
  \item \texttt{Map} Sammlung von key/value Paaren
  \item \texttt{Map} Klasse ist unver-$\Delta$
  \item jeder beliebige value kann von einen eindeutigen Schlüssel
  beschrieben werden
    
  \item wenn wir auf einen Schlüsselzugreifen wollen, den es nicht
  gibt wird eine Exception geworfen (was auch Sinn macht, denn man
  kann ja nicht auf was zugreifen, was es gar nicht gibt):
 
  \lstinputlisting{examples/map_examples.scala}

  macht man den \texttt{Map}-Zugriff mit get, so wird die 
  \texttt{Option} (\texttt{Some} \oder \texttt{None}) zurückgegeben
  \item mit \texttt{-= key} kann man Elemente aus einer Map
  entfernen
  \item mit \texttt{.contains} kann man testen, ob ein Schlüssel in
  der Map enthalten ist
\end{itemize}


\subsection{Traversieren, Filtering, Folding und Reducing}
\begin{itemize}
  \item traveriseren via \texttt{foreach}
      
  \item \texttt{filter} wird verwendet, um beim Traversieren durch eine
  Collection bestimmte Elemente herauszufiltern:
  
  \lstinputlisting{examples/filter.scala}
  
  \item \texttt{folding} \und \texttt{reducing} werden beide verwendet, um
  eine collection zu schrumpfen, wobei folding immer mit einem 
  \textit{seed} beginnt:
  
  \lstinputlisting{examples/folding_reducing.scala}  
\end{itemize}


\subsection{Currying}
\begin{itemize}
  \item betrachten \texttt{sum}, bei der man die Grenzen a \und b nicht mehr
  angeben muss
  
  \lstinputlisting{examples/currying.scala}
  
  \item wir werden nun Funktionen, die Funktionen zurückgegeben,
  behandelt?
  
  \lstinputlisting{examples/currying_1.scala}
  
  hier wird \texttt{sum} zuerst zur Quadratfunktion \texttt{(x $=>$ x * x)}
  angewendet \und die reslutierende Funktion wird dann auf die Argumentenliste
  \texttt{(1, 10)} angewendet 
  \item stammt vom Mathematiker \textbf{Haskell Curry} \und transformiert
  eine Fkt., die mehrere Parameter, nimmt in eine Kettenfunktion, die 
  nur einen Parameter nimmt
  \item in Scala werdem curried Funktion mit mehreren Parameterlisten
  definiert:
  
  \lstinputlisting{examples/curried_functions.scala}
  
  \item \uline{Verwendung}: spezialisierte Fkt. hat, die nur für 
  bestimmte Daten geignet ist
\end{itemize}


\subsection{Lazy Vals}
wenn man eine Variable als \texttt{lazy} deklariert, dann sollte
man auch alle Verwendungen davon ebenfalls auf \textit{lazy} stellen 

\lstinputlisting{examples/lazy_vals.scala} 
\pagebreak


\section{Klassen und Objekte}
\begin{itemize}
  \item Klasse für rationale Zahlen:
  
  \lstinputlisting{examples/rational_numbers.scala}
  
  \item \textbf{private members}: durch spezielles Keyword gekennzeichnet
  \und können nicht außerhalb der Klasse angesprochen werden
  \item \textbf{Objekterstellung}\footnote{erfolgt nach 
  \textit{lazy evaluation}}:
  
  \lstinputlisting{examples/object_creation.scala}
  
  
  $\Rightarrow$ mittels Punktnotation kann auf die Attribute zugegriffen
  werden
  \item \textbf{Vererbung}: jede Klasse erweitert eine Superklasse. Ist
  keine Klasse angegeben, so erbt es per \textit{default} von
  \texttt{scala.AnyRef}
  
  \lstinputlisting{examples/vererbung.scala}
  
  \item eine Klasse erbt alle Methoden \und Variablen der Oberklasse, will
  man eine geerbte Methode überschreiben, so muss man das Schlüsselwort    
  \item \textbf{Abstrakte Klassen}: 
  
  \lstinputlisting{examples/abstrakte_klassen.scala}
  
  \texttt{IntSet} ist als abstrakte Klasse gekennzeichnet, d.h. von 
  ihr können keine Objekte erzeugt werden
  
  Implementierung einer abstrakten Klasse
  
  \lstinputlisting{examples/implementierung_einer_abstrakten_klasse.scala}
  
  \item \textbf{traits}: traits sind wie abstrakte Klassen, nur 
  dass sie dafür geschaffen wurde, um an andere Klassen ergänzt zu
  werden
  
  \lstinputlisting{examples/traits.scala}
  \item \textbf{objects}: statt class kann man auch objects davor 
  schreiben
  \und dadurch ist das \textbf{Singleton-Pattern} sichergestellt:
  
  \lstinputlisting{examples/object.scala}
  
  \item jede Deklaration ohne ein Sichtbarkeits/Scopewort ist per 
  default
  \textit{public}\footnote{dafür gibts kein Schlüsselwort}
  \item mit \texttt{equal} vergleicht man, ob Objekte den gleichen
  Werte besitzen
  \item mit == \und != vergleicht man Wertgleichheit
\end{itemize}


\subsection{Klassen}
\begin{itemize}
  \item in Klassen werden \textit{fields} \und \textit{Methoden} angelegt,
  die als \texttt{members} bezeichnet werden
  \item alle Methodenparameter sind vom Typ \texttt{val} $\Rightarrow$ 
  können nicht ver-$\Delta$ werden
  \item werden in Packeten definiert \und spielen eine ähnliche 
  Rolle wie in Java
  \item jedes Java-Packet ist auch eine Scala-Packet (vice versa)
  \item jede Klasse kann via \textit{mixin} von mehr als einer Klasse
  erben, denn per default kann nur von einer Klasse gererbt werden
  \item jede Java-Klasse wird als gewöhnliche Scala-Klasse angesehen \und 
  jedes Java-Interface kann als Scala-\textit{trait} angesehen werden
  \item ein Beispiel für eine verschachtelte Klasse:
  
  \lstinputlisting{examples/nested_classes.scala}
  
  \item \texttt{private}: deklariert man solche Variablen so, so kann man auf
  diese Variablen nur mit einer Methode der Klasse angesprochen werden, in
  der diese definiert wurde $\Rightarrow$ normale Punktnotation geht nicht
  
  \lstinputlisting{examples/private_classes_example.scala}
  
\end{itemize}


\subsection{Hierarchie}
\begin{itemize}
  \item in Scala ist alles, bis auf eine Methode eine Instanz von
  einer Klasse $\Rightarrow$ alle Primitven aus Java (wie \uline{z.B.} int) 
  werden als Instanzen behandelt \und dies wird bei Kompilierung gemacht
  \item \texttt{Any} ist die Top-Klasse, es hat zwei Unterklassen:
  \texttt{AnyVal} \und \texttt{AnyRef}
  \item \texttt{AnyVal}  basiert auf \textit{value classes}, also
  \textbf{boolean, byte, short, char, int, long, float, double}
  \item Mutterklasse aller Scala-Klassen ist \texttt{Scala.Any}
  \item am untersten Ende der Scala-Typen steht \texttt{scala.Null}
  \und \texttt{scala-Nothing}
  \item \texttt{scala.Null} ist ein \textit{subtype} von allen Referenztypen
  
  $\Rightarrow$ einzige Instanz ist die \textbf{null} Referenz
  \item \texttt{scala.Nothing} ist \textit{subtypen} von jeden anderen Typen
  
  $\Rightarrow$ von diesen Typen existieren keine Instanzen
  \item wenn man sich an die Namenskonventionen hält, dann sind
  die Scala-Repräsentanten der Primitiven Datentypen der JVM:
  \begin{itemize}
    \item \texttt{Int}
    \item \texttt{Long}
    \item \texttt{Double}
    \item \texttt{Float}
    \item \texttt{Boolean}
    \item \texttt{Char}
    \item \texttt{Byte}
  \end{itemize} 
  
  alle Unterklassen von der Klasse \texttt{AnyVal}
\end{itemize}


\subsection{Import}
\begin{itemize}
  \item Syntax:
  
  \lstinputlisting{examples/import.scala}
  
  \item mehrere Klassen \oder Objekte können vom selben Paket importiert
  werden, indem sie einfach in \textit{brackets} geschrieben werden
  
  \lstinputlisting{examples/import_bracktes.scala}
  
  \item können alias für Imports definieren:
  
  \lstinputlisting{examples/import_alias.scala}
  
  \item man kann auch bestimmte Klassen vom import \enquote{excluden}
  
  \lstinputlisting{examples/import_exclude.scala}
  
\end{itemize}


\subsection{Felder zu einer Klasse hinzufügen}
\begin{itemize}
  \item den Konstruktor-Parameter muss man in einer Klasse noch explizit
  Werte zuweisen, damit man via der Punktnotation auf diese zugreifen kann
  
  \lstinputlisting{examples/add_fields_to_class.scala}
  
  \item mit \texttt{that} greift man gerade auf das Objekt \texttt{SoUndSo}
  zu
  der aufrufenden Methode zu
\end{itemize}


\subsection{Self-Referenz}
\begin{itemize}
  \item das Schlüsselwort \texttt{self} zeigt auf eine
  Objektinstanz der gerade ausgeführten Methode \oder wenn es
  in einem Konstruktor verwendet wird, dann auf die Instanz,
  die in dem Konstruktor angelegt wird:
  
  \lstinputlisting{examples/this.scala}
\end{itemize}


\subsection{Overriding}
\begin{itemize}
  \item muss man dann hinschreiben, wenn abgeleitete Klassen Methoden, Felderm
  Variablen usw. von ihren Elternklassen überschreiben wollen
  \item überschreibt man etwas, ohne keyword \itbf{override} zu verwenden
  gibts einen Fehler $\Rightarrow$ potentielle Fehler werden dadurch
  abgefangen
  \item Sachen, die als final deklariert sind, kann man nicht 
  \itbf{overriden}
  
  \lstinputlisting{examples/overriding.scala}
  
\end{itemize}


\subsection{Overloading}
\begin{itemize}
  \item gleiche Fkt.namen mit verschiedenen Signaturen lösen verschiedene 
  Nachrichten aus
  
  \lstinputlisting{examples/overloading.scala}
  
\end{itemize}


\subsection{Abstraktion}
\begin{itemize}
  \item eine wichtige Aufgabe von Komponentensystemen ist, wie man von den
  erforderlichen Komponenten abstrahiert
  \item es gibt folgenden Formen der Abstraktion in Progg-Sprachen:
  \begin{enumerate}
    \item \textit{Parametrisierung} (typisch Funktional)
    \item \textit{abstract members} (typisch objekt-orientiert)
  \end{enumerate}

  \item die folgende Klasse \texttt{GenCell} ist generisch
  
  \lstinputlisting{examples/gencell.scala}
  
  \item ebenso wie Klassen können auch Methoden Typenparameter besitzen.
  
  die folgende Methode vertauscht den Inhalt von zwei Zellen:
  
  \lstinputlisting{examples/gencell_swap.scala}
  
  \item Anwendung von swap:
  
  \lstinputlisting{examples/gencell_swap_usage.scala}
  
  Scala hat jedoch ein hochentwickeltes \textit{type inference system}, welches
  die korrekten Typen anhand der Argumente erkennt $\Rightarrow$ im obigen 
  Codeschnipsel zur Anwendung der swap-Methode kann man die Typangaben in den
  \textit{square brackets} auch weglassen
  \item \textbf{Varianz}: 
  \begin{itemize}
    \item Scala erlaubt die Varianz von Typparametern durch die Zeichen + \und 
    -
    \item + $\ldots$ vor einem Parameter sagt aus, dass der Konstruktor
    \itbf{covariant} ist
    \item - $\ldots$ vor einem Parameter sagt aus, dass der Konstruktor
    \itbf{contravariant} ist
  \end{itemize}
\end{itemize}


\subsection{Precondition}
\begin{itemize}
  \item kann man bei Konstruktoren nehmen, damit bestimmte Werte von vornherein
  ausgeschlossen werden:
  
  \lstinputlisting{examples/precondition.scala}
\end{itemize}


\subsection{Companion Objekte}
\begin{itemize}
  \item wenn eine Klasse \und ein Objekte innerhalb einer Datei, im selben
  Packet den gleichen Namen haben, werden diese \textit{Companion Objekte}
  genannt
  \item \textbf{Apply}: wird als \textit{factory} Methode verwendet
  
  \lstinputlisting{examples/apply.scala}
  
  \item \textbf{Unapply}: wirkt irgendwie als Extraktionmechanismus von
  bestimmten Werten einer Instanz $\Rightarrow$ Pattern Matching
  benutzt diesen Mechanismus ausführlich
  
  \lstinputlisting{examples/unapply.scala}
\end{itemize}


\subsection{Komposition}
$\Rightarrow$ hat flexible modulare Mixin-Komposition Konstrukte für 
Klassen-Komposition


\begin{itemize}
  \item fangen einfach mal mit einem kleinen Beispiel an:
  
  \lstinputlisting{examples/abstract_list_iterator.scala}
  
  \begin{itemize}
    \item \textbf{traits} ist eine spezielle Form einer abstrakten Klasse, welche
    keine Werte für den Parameter für den Konstruktor hat
    \item traits können in allen Kontexten verwendet werden, in denen abstrakte
    Klassen auftauchen
    \item nur traits können als mixins verwendet werden
  \end{itemize}
  
  \item \textbf{mixin-class composition}: betrachten folgende Interatoren
  
  \lstinputlisting{examples/iterators_for_mixin_class_composition.scala}
  
  \begin{itemize}
    \item nun wollen die Funktionen des \texttt{RichIterators} und des
    \texttt{StringIterators} in einer Klasse verwenden $\Rightarrow$ mit
    Einfachvererbung \und Interfaces kann man das nicht machen
    \item \uline{Idee}: \textit{mixin-class composition}
    
    \lstinputlisting{examples/mixin_class_composition.scala}
    
  \end{itemize}
\end{itemize}


\subsection{Abstrakte Klassen}
\begin{itemize}
  \item von solchen Klassen können keine Instanzen erzeugt werden:
  
  \lstinputlisting{examples/abstract_class.scala}
  
  \item Methoden einer abstrakten Klasse brauchen keinen Extramodifier, der
  das anzeigt, da die Klasse diese Aufgabe bereits übernimmt
\end{itemize}


\subsection{Dekomposition}
von Objekten via Pattern-Matching


\begin{itemize}
  \item wollen einen simplen Taschenrechner für algebraische Berechnungen \und 
  der Plus-Operation implementieren:
  
  \lstinputlisting{examples/algebraic_calculator.scala}
  
  \item so ein Ansatz verlangt, dass alle Operationen zu einer bestimmten
  Struktur durchwandert werden
  
  \begin{itemize}
    \item intern definierte Methoden müssen deswegen ebenfalls ungewollt
    durch die ganze Struktur gelegt werden $\Rightarrow$ DRY wird
    verletzt
  \end{itemize}
\end{itemize}


\ulbf{Pattern Matching über Klassenhierarchie}


\begin{itemize}
  \item in FP sind Datenstrukturen von ihren Operationen getrennt  
  \item während Datenstrukturen gewöhnlich durch algebraische Datenstrukturen
  definiert sind, benutzen Operationen auf solchen Datentypen 
  \itbf{pattern matching} als Grundprinzip der Dekomposition
  \item durch \itbf{pattern matching} kann man eine einzelne 
  \texttt{eval}-Funktion implementieren, ohne das künstliche Zusatzfunktion
  aufzusetzen
  \item Klassen werden mit \textbf{case} \enquote{getagt}:
  
  \lstinputlisting{examples/algebraic_calculator_case.scala}
  \item nun folgt die Implementierung der \texttt{eval}-Funktion nach dem
  Pattern-Matching Prinzip:
  
  \lstinputlisting{examples/algebraic_calculator_pattern_matching.scala}
  
  \item der matchende Ausdruck $x$ \textbf{match} $\{ case\: pat_1 => e_1
  case\: pat_2 => e_2 \ldots \}$ matchd den Wert $x$ gegen die Muster $pat_1, 
  pat_2, \ldots$
  
  
  $\Rightarrow$ dadurch können neue Funktionen leicht zu einem bestehenden
  System hinzugefügt werden
\end{itemize}


\subsection{Case-Klassen}
\begin{itemize}
  \item es wird einfach das Schlüsselwort \textbf{case} vor Klassen bzw. 
  Objekten geschrieben
  \item \textbf{case-Klassen} generieren automatisch 
  \textit{factory method} mit denselben Argumenten als Primärkonstruktor
  \item Case-Klassen haben implizit eine Konstruktor-Funktion, 
  welche denselben Namen wie die Klasse trägt
  \item Case-Klassen \und Case-Objekte haben implizit die Methoden
  \texttt{toString, equals} \und \texttt{hashCode} implementiert \und 
  überschreiben die Methoden von \texttt{AnyRef}; sie haben implizite 
  getter-Methoden, um an die Argumente der Konstruktoren zu gelangen
  \item \uline{Verwendung}: Wenn man mit baumartigen, rekursiven
  Datenstrukturen zu tun hat
  \item Instanzen von Case-Klassen können ohne die \texttt{new}-Anweisung
  erzeugt werden
  
  \lstinputlisting{examples/case_class.scala}  
  
  \item Case-Klassen erlauben die Erstellung von \textit{patterns}, welche
  zu case-class Konstruktoren gehören:
  
  \lstinputlisting{examples/case_class_one_more_example.scala}
  
\end{itemize}


\subsection{Pattern Matching}
\begin{itemize}
  \item ist eine generalsierte \texttt{switch}-Anweisung für Klassenhierarchien
  \item anstelle der switch-Anweisung gibt es eine \textbf{match}-Operation
  
  \lstinputlisting{examples/match.scala}
  
  \item \textbf{Fibonaccizahlen} verschiedenen Varianten:
  
  \lstinputlisting{examples/pattern_matching_fibonacci.scala}
  
  \item \textbf{Matching Any Type}:
  
  \lstinputlisting{examples/matching_any_type.scala}
  
  \item \textbf{Datentypen testen}: schreiben eine Methode, die testet,
  ob ein hereinkommendes Objekt ein \texttt{String}, \texttt{Integer} \oder 
  was anderes ist
  
  \lstinputlisting{examples/pattern_datatypes.scala}
  
  \item \textbf{Case-Klassen} gehören auch zu dieser Klasse:
  
  \lstinputlisting{examples/pattern_matching_case_class.scala}
  
  \item \textbf{verschachteltes Pattern-Matching in case-Klassen}:
  
  \lstinputlisting{examples/pattern_matching_nested.scala}

  \item \textbf{Pattern-Matching Listen}:
  
  \lstinputlisting{examples/pattern_matching_lists.scala}
  
\end{itemize}


\subsection{traits}
\begin{itemize}
  \item ist besondere Variante eines \itbf{mixins}\footnote{zusammengehöriges, 
  mehrfach verwendbares Bündel von Funktionalität bezeichnet, das zu einer Klasse 
  hinzugefügt werden kann}
  \item trait besitzt eine gemeinsame Basisklasse mit der Klasse, 
  auf die das trait angewendet wird
  \item traits sind die Grundlage für \textit{reuse} \und können via
  \texttt{extends} \oder \texttt{with} von Klassen eingebunden werden
  \item in Scala können traits in Objekten erst bei Instanziierung
  einbinden
  \item traits unterstützen nicht beliebige Konstruktoren \und nehmen auch
  keine Argumente für ihre Konstruktoren auf
  
  $\Rightarrow$ können keine Argumente an ihre Elternklassen weitergeben
  
  \lstinputlisting{examples/trait_creation.scala}
  
  $\Rightarrow$ Reihenfolge der Abarbeitung der trais ist von links nach
  rechts

  \item traits können auch als abstrakt deklariert haben (was auch immer
  das bringen soll) \und können eigene Felder deklarieren, die dann
  von den \enquote{erbenden} Klassen benutzt werden können
  \item durch traits kann man einer Klasse einfach neue Funktionen
  einbinden, ohne dass man sich Sorgen um ein etwaige Vererbung machen
  muss
  \item \uline{Hauptanwendungsgebiet}: \textit{turning a thin interface
  into a rich interface}
  \item \textbf{Klassen \oder traits?} falls ein traits mehr als einmal 
  als Elternteil von anderen Klassen dient, so als Klasse machen; vermeide
  konkrete Felder in traits, welche nicht mit geeigneten default-Werten
  initialisiert werden können $\Rightarrow$ verwende lieber abstrakte
  Felder
\end{itemize}
\pagebreak


\section{Varianz}
Regeln festlegen, nach denen parametrisierte Typen als Parameter übergeben
werden können


\subsection{Varianzregeln}
\begin{itemize}
  \item $\Delta$ Container sollten invariant sein
  \item unver-$\Delta$ Container sollten kovariant sein
  \item die Inputs von Transformationen sollten kontravariant sein
  \und die Outputs von Transformationen sollten kovariant sein
\end{itemize}
  

\subsection{Invariante Parametertypen}
\begin{itemize}
  \item in Scala ist \texttt{Array[T]} \itbf{invariant}, d.h. 
  man kann nur \texttt{Array[String]} an \texttt{foo(a: Array[String])}
  übergeben
  \item invariante Typparameter schützen, wenn wir mit
  \textit{veränderlichen} Datentypen hantieren
\end{itemize}


\subsection{Kovariante Parametertypen}
\begin{itemize}
  \item Kennzeichen: \texttt{+} vorm Typparameter, \uline{z.B.} 
  \texttt{List[+T]}
  \item Anwendung: wenn wir mit \textit{read-only} container umgehen
  
  \lstinputlisting{examples/covariant_parameter_types.scala}
\end{itemize}


% Weblinks

\begin{comment}
\begin{itemize}
  \item http://www.scala-ide.org/ | Plugin für Eclipse
  \item 
  \item n
\end{itemize}
\end{comment}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       __       __  .___________.
%     |  |     |  | |           |
%    |  |     |  | `---|  |----`
%   |  |     |  |     |  |     
%  |  `----.|  |     |  |     
% |_______||__|     |__|     
%
% Literatur
% \end{comment}
\begin{comment}
\addcontentsline{toc}{section}{Literatur}
\bibliographystyle{acm}
\bibliography{literatur}
\end{comment}
\end{document}
