%% config
\newcommand{\home}{../../latex/styles} % home directory - need for absolute paths with 

%% documentclass
\input{\home/documentclass_normal_oneside}

%% generell-styling
\include{\home/style_proggen}

%% meta-tags for pdf
\newcommand{\pdfauthor}{Matthias Günther}
\newcommand{\pdftitle}{git}
\newcommand{\pdfsubject}{Aufzeichnungen zur Fortbildung}
\newcommand{\pdfkeywords}{git, svn, SCM, SVN}
\newcommand{\motto}{Scala - just scale your large applications}
\newcommand{\tutor}{}
\newcommand{\disclaimer}{(Die Autoren übernehmen keine Garantie und Haftung 
für die Korrektheit des Skriptes. Das Skript ist unter den Namen von Matthias 
Günther veröffentlich.)}
\newcommand{\publisher}{Der Helex-Matze Verlag $\sum\limits_{i=1}^{n}i$}
\newcommand{\pdfemail}{matthias.guenther@wikimatze.de}
\newcommand{\correctiontext}{Kommentare/Korrekturen an}
\newcommand{\homepagetext}{Homepage}
\newcommand{\homepage}{wikimatze.de}
\newcommand{\coverdisclaimer}{Copyright Skript-Covers}
\newcommand{\covercopyright}{\textsc{Ubisoft} (\url{ubi.com})}

% label for programming-language


%% fancy-header
\input{\home/style_header_oneside}

%% setting the infos for the pdf
\input{\home/info_hypersetup}

%% environments
\input{\home/style_environments_normal}

%% cover
\input{\home/style_cover_german}

% label for programming-language
\input{\home/style_scala}
\begin{document}
\input{\home/style_starting_document_without_cover}


\section{Einführung}
\begin{itemize}
  \item \textbf{Kompilierung}: \texttt{scalac}\footnote{Resultat sind JVM
  Klassen-Datein, welche man in JARs packen kann, hierbei wird jedoch class,
  trait \oder object-Definition verlangt} bzw. 
  \texttt{fsc}\footnote{schnellere Kompilierung}
  \item \textbf{Ausführung}:\footnote{Programm wird kompiliert \und danach
  gleich ausgeführt} \texttt{scala}
  \item \textbf{Interpreter}: nur \texttt{scala} in Konsole eingeben
\end{itemize}


\subsection{Einfache Programme}
\begin{itemize}
  \item Hello Helex:
  
  \lstinputlisting[label=src:hello_helex.scala]{beispiele/hello_helex.scala}
  
  $\Rightarrow$ Datei muss wie das Objekt heißen, damit es ausgeführt werden
  kann
  \item Zahlen:
  
  \lstinputlisting[label=src:numbers.scala]{beispiele/numbers.scala}
  
  \item ein Programm, dass ein String in Int parsed und dabei alle Zahlen 
  der Eingabe aufsummiert:
  
  \lstinputlisting[label=src:input_parsing.scala]{beispiele/input_parsing.scala}
  
  \begin{itemize}
    \item \itbf{Option}:
    \begin{itemize}
      \item \texttt{Option} ist Container, der Null (dann ists 
      \texttt{None}) \oder ein Element dann ists \texttt{Some(theElement)}
      enthält
      \item durch Option verhindert man \texttt{null} Pointer Exceptions
      
      $\Rightarrow$ gut wenn man Business-Logik schreibt und diesen Fall
      nicht in jeder Abfrage, sondern einfach am Ergebnistyp der Funktion
      festlegt\footnote{denke an Adminbill aus pictrs}
      \item Parsing des Strings: sollte eben keine zahl eingegeben
      werden, so wird keine Exception geworfen, sondern die Ausgabe
      einfach auf \texttt{None} gemappt
    \end{itemize}
    \item \itbf{sum}
    \begin{itemize}
      \item in der Methode \texttt{sum} definieren wir keinen return-Wert
      \item \texttt{in} Parameter ist vom Typ 
      \texttt{Seq}\footnote{\texttt{Seq} ist \textit{supertrait} von 
      \texttt{Array, List} \und andere \textit{Collections}}, was ein 
      ein \textit{trait}\footnote{denke Interface aus Java} ist
      \item \texttt{traits}\footnote{traits beheben das Diamanten-Prob. 
      der multiplen Vererbung, da eine Klasse beliebig viele traits haben} 
      können implementierte Methoden beinhalten \und sind am Besten mit 
      mixins aus Ruby zu vergleichen
      \item mit \texttt{flatMap} ruft die Methode \texttt{toInt}
      für jedes Element der Sequenz in \texttt{in} auf
      \item mit $s => toInt(s)$ definieren wir eine anonyme
      Funktion, die einen einzelnen Parameter $s$ nimmt \und diesen
      an die Funktion \texttt{toInt} weitergibt
      \item \texttt{foldLeft}\footnote{kann man gut verwenden, wenn man die 
      Werte einer Sequenz aufsummieren will} nimmt einen einzelnen Parameter als
      \textit{seed} \und und schreibt das Ergebnis der inneren
      Funktion an diesen \textit{seed} zurück. Dabei wird der 
      \textit{seed} solange weiter $\uparrow$, bis alle Elemente der 
      Sequenz durchlaufen wurden
    \end{itemize}
  \end{itemize}
\end{itemize}
\pagebreak


\section{Eigenschaften zur Sprache}
\begin{itemize}
  \item Wofü Scala geeingnet ist:\textit{language ideal for today’s scalable,
  distributed, component-based applications that support concurrency and
  distribution}
  \item \textbf{Merke}: \textit{Is a statically typed\footnote{der Typ 
  einer Variable ist für die gesamte Lebenszeit der Variable fest}, 
  mixed-paradigm, JVM language with a succinct, elegant, and flexible 
  syntax, a sophisticated type system, and idioms that promote 
  scalability from small, interpreted scripts to large, 
  sophisticated applications.}
  \item Programmiersprachen für Softwarekomponenten müssen \textbf{skalierbar}
  sein $\Rightarrow$ Konzentration bei Scala auf Abstraktion, Komposition
  und Dekomposition
  \item skalierbare Unterstützung für Komponenten kann nur erreicht werden,
  wenn OOP generalisiert und mit funktionalen Aspekten (FP) einer
  Programmiersprache vereinigt werden
  \item Scala arbeitet gut mit Java und C\# zusammen
  \item Typsystem von Scala hat folgende Vorteile:
  \begin{enumerate}
    \item Abstrakte Typdefinitonen und vom Pfad 
    abhängige Typen\footnote{\enquote{\textit{v}Obj calculus}} unterstützen
    \item modulare mixing Komposition
    \item \textit{views}\footnote{ermöglichen Komponenten-Adaption in 
    einem modularen Weg}
  \end{enumerate}
  \item Scala Klassen \und Objekte können von Java-Sachen erben \und Java-
  Interfaces implementieren $\Rightarrow$ man kann Scala-Code in einem 
  Java-Framework\footnote{wicket} verwenden
  \item \textbf{high-order functions}: sind Funktionen, die Funktionen als
  Argumente nehmen \oder Funktionen als Ergebnis zurückliefern \und diese
  werden von Scala unterstützt
  \item \textbf{scope} verschachtelte Funktionen können auf alle Parameter 
  \und lokalen Variablen innerhalb ihrer Umgebung zugreifen
  \item Funktionen-Def mit nur einer Zeile benötigen keine geschweiften Klammern
  \item \textbf{id: type}-Syntax wird von Scala verwendet 
  \item \textbf{unit} wird statt void in Scala verwendet
  \item Scala hat eine Darstellung on Javas \texttt{void}, nämlich 
  \texttt{Unit}\footnote{kann man explizit zurückgeben, wenn man einfach
  () beim Returnwert einer Funktion hinschreibt}
  \item alle Kontrollstrukturen von Java sind auch in 
  Scala\footnote{for-Schleifen wurde stark vereinfacht :)} vorhanden
  \item in Scala hat alles einen öffentlichen Zugriff, es sein denn
  es wird anders definiert
  \item \textbf{Klassen mit Argumenten}: Argumente dienen als
  Konstruktoren für die Klasse
  
    \lstinputlisting[label=src:klassen_constructor.scala]{beispiele/klassen_constructor.scala}

  \item Scala-Objekt ist Instanz einer Klasse \und kann deswegen als
  Parameter von Methoden agieren kann
  \item Klassen, Objekte \und \itbf{traits}\footnote{um es in Java-Sprache
  auszudrücken sind \textit{traits} Interfaces mit einer Superklasse, die
  nicht-abstrakte Methoden beinhalten dürfen} können innere Klassen, Objekte
  \und traits haben, welche Zugriff auf \textit{private} Methoden,
  Variablen und so weiter haben
  \item die Import-Methode kann innerhalb von Blöcken verwendet werden
  $\Rightarrow$ können dadurch feingranular den scope festlegen
  \item Scala ist statisch typisiert
  \item \textbf{Nothing}: eine Methode mit diesen Rückgabewert, wird
  normalerweise niemals laufen
  \item \textbf{Any} ist die Mutter aller Klassen in Scala
  \item \textbf{AnyRef} bedeutet dasselbe wie Javas \texttt{Object},
  jedoch mit den Unterschied, dass mit == die inhaltliche Gleichheit von 
  Objekten gemeint ist - will man die Referenz von Objekten beurteilen,
  dann nimmt man lieber die Methode \texttt{eq}
  \item der return-Wert von Funktionen ist per default die letzte Zeile einer
  Methode\footnote{man kann aber auch explizit return angeben}
  \item \textbf{call-by name} kann man in Scala durch $=>$ für Funktionsaufrufe 
  anfordern:
  
  \lstinputlisting[label=src:call_by_name.scala]{beispiele/call_by_name.scala}
  
  $\Rightarrow$ es kommen verschiedene Zeiten heraus $\Rightarrow$ in
  \textit{delayed} wird bereits reingegangen bevor \textit{nano} 
  aufgerufen wird und somit wird \textit{nano} zweimal aufgerufen
  \item \texttt{[B $>:$ T]} heißt, dass \texttt{B} mindestens von derselben
  Klasse wie \texttt{T}
  \item \textbf{impliziten Konversion}: man fügt einer eigentlichen als 
  \texttt{final} deklarierten Klasse noch
  zusätzliche Methoden hinzu\footnote{einfach implicit vor Methodendef
  schreiben}
  \item Scala ist FP, d.h. in dem Sinne, dass jede Funktion einen Wert hat
  \item Scala ist statisch Typisiert \und das Typsystem unterstützt:
  \begin{itemize}
    \item \textbf{generische Klassen}
    \item \textbf{Varianz}-Annotationen
    \item obere \und untere Schranken für Typen
    \item \itbf{compound types}
    \item polymorphe Methoden
    \item Scala ist erweiterbar: man kann leicht neue Sprachkonstrukte
    zur Sprache ergänzen
  \end{itemize}
  \item Scala kompiliert in normalen Java Bytecode
  \item Scala arbeitet gut mit Java \und .NET an
  \item jede Java Klasse kann als eine normale Scala-Klasse verwendet werden
  $\Rightarrow$ deswegen sind alle Java-Bibos auch direkt in Scala verwendbar
  \item gewöhnlicher Java-Code ist kein valider Scala-Code, aber wenn der
  Java-Code einmal kompiliert wurde, dann kann er vom Scala-Code verwendet
  werden
  \item Scala behandelt das auftauchen von Bezeichnern zwischen zwei
  Ausdrücken als Methodenaufruf
  \item Scala läuft wie Java auf derselben JVM \und sie teilen sich deshalb
  den gleichen Garbage-Collector
  \begin{itemize}
    \item auf Java Bytecode kann Scala:
    \begin{itemize}
      \item Objekte instanziieren
      \item Methoden aufrufen
      \item exceptions werfen/abfangen
      \item Klassen erweitern
      \item Interfaces implementieren
    \end{itemize}    
    \item Java-Klassen als Mixins, wenn diese als Quellcode vorhanden
    sind
    \item Java \enquote{locking \und concurency model} wird unterstützt, wird
    aber normalerweise von Scala gerwapped
  \end{itemize}
  \item Imports sind wie in Java, nur mit mehr Features (denke ans
  Alias) \und imports können allen Stellen des Programms gemacht werden
  \item wenn Typen offensichtlich sind, dann muss man diese nicht angeben, kann
  aber zu bösen Fehlern führen
  \item Generics\footnote{statt Generics sagt man in Scala zu 
  dynamischen Datentypen von Funktionen \itbf{parameterized types}}:
  \begin{itemize}
    \item Klassen \und traits können generisch gemacht werden
    \item via \itbf{Typparameter} (Nonvariant, Covariant, Contravariant)
    \item obere \und untere Schranken
  \end{itemize}
  \item Scala erlaubt die Definition von parameterlosen Methoden \und jedesmal
  wird so eine Funktion aufgerufen, wenn dessen Name verwendet wird
  \item FP Eigenschaften: \textit{Higher-order functions}; 
  \textit{Function closure support}; Rekursion als \textit{flow control}; 
  \textit{pure Funktionen} $\Rightarrow$ keine 
  Seiteneffekte\footnote{viele Datenstrukturen sind immutable, mit 
  \texttt{val} sind immutable \und mit \texttt{var} sind mutable};
  \textit{Pattern Matching}
  \item immutable \texttt{val} müssen initialisiert werden!  
  \item Klassen können überall in einem Programm auftauchen: top-level,
  innerhalb von anderen Klassen (\textit{inner classes}), innerhalb von
  Codeblöcken (\textit{local classes}) \und innerhalb von Ausdrücken 
  (\textit{anonymous classes}) $\Rightarrow$ analog gilt das für Funktionen
  in Scala, nur das Funktionen nicht als Top-Level deklariert werden können
  \item Scala ist eine stark typisierte Sprache: \textit{class types},
  \textit{variant class type parameters}, \textit{virtual types}, 
  \textit{qualified class types},  \textit{compound types}\footnote{kann
  man festlegen, dass ein Wert eine Instanz von einer Liste von Klassen
  ist}, \textit{singleton types}\footnote{für Typen gibt es genau einen
  Wert}, \textit{explicit self types}\footnote{sind Annotationen, die den Typ 
  einer aktuellen Instanz einer Klasse festlegen}
  \item Scala unterstützt \itbf{Symbole} aus Ruby
  \item \texttt{null} gibts in Scala, aber ab in die Tonne damit \und 
  besser \texttt{Option} verwenden
  \item wenn man \textbf{final} vor Klassen \oder traits schreibt, dann
  verhindert man, dass davon Klassen abgeleitet werden können
  \item \textbf{super} ist analog zu this, aber es bindet an die Elternklasse
  \item \textbf{this} wie ein Objekt auf sich alleine zeigt
  \item das \$ verwendet Scala intern für irgendwas, also ebenso wie
  die keywords nicht als Variablennamen verwenden
  \item Scala-Konvention: Klammern bei Methodenaufrufen vermeiden, wenn
  diese keine Seiteneffekte verursachen
  \item \itbf{Generatoren}:
  
  \lstinputlisting[label=src:generators.scala]{beispiele/generators.scala}
  
  der \textit{left-arrow} Operator wird eben Generator genannt, der er die
  einzelnen Elemente aus der Collection generiert
  \item der $=>$ Operator gibt an, dass aktuelle Argumente für diesen Parameter
  unausgewertet übergeben werden.
    
  die Argumente einer solchen Funktion werden jedesmal ausgewertet, wenn der
  formale Parameter erwähnt wird
  
    \lstinputlisting[label=src:unausgewertete_parameter_uebergabe.scala]{beispiele/unausgewertete_parameter_uebergabe.scala}
  \item die Behandlung von Variablenzugriffen als Methodenaufrufen ermögicht
  es in Scala \textbf{properties} zu definieren. Im folgenden Beispiel wird
  die Eigenschaft \textit{degree} definiert, welche nur einen Wert entspricht,
  der größer \oder gleich -273 ist
  
  \lstinputlisting[label=src:properties.scala]{beispiele/properties.scala}
  \item für jede Variable \textbf{var} \textit{x: T} definiert Scala
  die folgenden \textit{setter} und \textit{getter} Methoden:
  
  \lstinputlisting[label=src:getter_setter.scala]{beispiele/getter_setter.scala}
  
  diese Methoden referenzieren und updaten die entsprechende Speicherzelle für
  die Variable, welche nicht direkt durch Scala-Programme beeinflussbar ist
  \item Kommentare:
\lstinputlisting[label=src:comments.scala]{beispiele/comments.scala}
  \item \textbf{def} wird zur Festlegung von Funktionen verwendet
  \item \textbf{Array Typen} werden Array[T] geschrieben \und 
  \textbf{Array-Zugriffe} werden mit a(i) statt a[i] geschrieben
  \item Scala unterscheidet nicht zwischen Identifier \und Operatorennamen,
  d.h. \texttt{xs filter (pivot $>$)} ist äquivalent zu 
  \texttt{xs.filter(pivot $>$)}
  \item alle Funktionen haben die \texttt{apply}-Methode, welche die 
  Funktion ausführen
  \item \textbf{Option[T]}
  \begin{itemize}
    \item ist Alternative zu Javas \texttt{null}
    \item \texttt{Option} hat nur die Werte \texttt{Some[T]} \oder 
    \texttt{None} haben
    \item \texttt{None} ist ein Objekt \und in einem Scala Programm gibt es
    nur eine Instanz von \texttt{None}
  \end{itemize}
\end{itemize}
  

\subsection{Paradigmen}
\ulbf{\kreis{1. } OOP-Paradigma}



\begin{itemize}
  \item alles ist ein Objekt
  \item Scala hat die typischen Mechanismen von OOP, aber ergänzt das ganze
  noch durch \textit{traits}, \textit{mixin composition}
  \item es gibt keine primitven Datentypen wie in Java, anstelle sind alle 
  numerischen Typen Objekte
  \item Scala unterstützt \textit{singleton object construct}
\end{itemize}


\ulbf{\kreis{2. }FP-Paradigma}


\begin{itemize}
  \item FP sind gut für Design-Probs wie \textit{concurrency}, da pure FP
  keine $\Delta$ Zustände erlaubt\footnote{um Synchronisation muss man
  sich nicht kümmern}
  \item in puren FP kommunizieren Programme durch den Autausch von
  nebenläufigen autonomen Prozessen $\Rightarrow$ Scala unterstützt dass
  durch seine \texttt{Actors Library}, aber es unterstützt auch
  veränderliche Elemente, wenn man das will
  \item Funktionen sind \itbf{first class}\footnote{d.h. sie können 
  an Variablen, an andere Funktionen usw. ähnlich wie Werte übergeben werden}
  \und Scala bietet \itbf{closures}\footnote{bezeichnet man 
  eine Programmfunktion, die beim Aufruf einen Teil ihres vorherigen
  Aufrufkontexts reproduziert, selbst wenn dieser Kontext außerhalb der 
  Funktion schon nicht mehr existiert $\Rightarrow$ sind ein mächtiges 
  Werkzeug zur Abstraktion} 
\end{itemize}


\ulbf{\kreis{3. } Skalierbarkeit}\footnote{es wurde designt, um von kleinen, interpretierten
Skripten zu großen, verteilten Anwendungen zu skalieren} wird durch folgende
Sachen gewährleistet:


\begin{enumerate}
  \item explizite \textit{self types}
  \item abstrakte \textit{type members} \und \textit{generics}
  \item verschachtelte Klassen
  \item \textit{mixin} Komposition durch Verwendung von \textit{traits}
\end{enumerate}


\ulbf{\kreis{4. }Performanz}


\begin{itemize}
  \item da Scala ja auf der JVM läuft, unterstützt auch die ganzen dafür
  entwickelten Optimierungsmethoden (Profilers, verteilter Cache, Clustering)
\end{itemize}


\subsection{Operationen sind Objekte}
\ulbf{Methoden sind funktionale Werte}


\begin{itemize}
  \item betrachten die folgende Funktion, welche überprüft, ob ein Array eine
  Element mit einer bestimmten Eigenschaft (Prädikat) hat:
  
  \lstinputlisting[label=src:array.scala]{beispiele/array.scala}
  
  \begin{itemize}
    \item der Elementtyp des Arrays ist beliebig, wird durch den Parameter [T]
    angegeben der exists-Methode angegeben 
    \item die zu testende Eigenschaft ist beliebig \und dies wird durch
    den Parameter $p$ der exists-Methode repräsentiert
    \item der Typ von \texttt{p} ist der \textit{Funktionstyp} $T => boolean$,
    welche als Werte alle Funktionen mit der Domäne $T$ und den Bereich von
    $boolean$ hat
    \item Funktionsparameter können wie normale Funktionen angewendet werden 
    (siehe im $p$ in while-Schleife)
    \item mithilfe der obigen Funktion können wir eine Funktion \texttt{forall}
  via Doppelnegation erstellen: Ein Prädikat gilt für alle Elemente eines Arrays,
  wenn es kein Argument gibt, dass nicht die Eigenschaft des Prädikats erfüllt
    \begin{itemize}
      \item \texttt{forall} definiert eine \textbf{geschachtelte Funktion} 
      $not\_p$, welche den Parameter $p$ negiert
      \item \texttt{forallAnonymous}: hier definiert $(x: T) => !p(x)$
      ein anonyme Funktion, die alle Parameter vom Typ $T$ nach $!p(x)$
    \end{itemize}
  \end{itemize}
  \item wenn Methoden Werte sind \und Werte Objekte, dann folgt, dass Methoden
  selbst Werte sind
\end{itemize}


\ulbf{Funktionen verfeinern}


\begin{itemize}
  \item da FunktionsTypen in Scala Klassen sind, kann man Sie in Unterklassen
  weiter verfeinern
  \item Klasse \texttt{Array[T]} erbt von der Funktion \texttt{Function1[int, T]}
  \und fügt Methoden für Array-Update, Array-Länge usw. hinzu
  
  \lstinputlisting[label=src:refining_functions.scala]{beispiele/refining_functions.scala}
\end{itemize}


\subsection{Varablendeklarationen}
\begin{itemize}
  \item werde wie Methoden definiert beginne aber mit einen der folgenden
  \textit{keywords}:
  
  \begin{Beschreibungfett}[lazy val]
    \item [var] können ihren Wert $\Delta$ (genauso wie Variablen in Java)
    \item [val] definiert nur Werte $\Rightarrow$ \textit{read only}
    \item [lazy val] wird erst dann zugewiesen, wenn die Variable
    verwendet wird 
  \end{Beschreibungfett}  

\end{itemize}


\subsection{if/else und while}
\begin{itemize}
  \item if/else wird eher selten verwendet \und verhalten sich eher wie
  der Ternary-Operator; while-Schleifen sind ebenso effizient wie 
  Rekursion\footnote{beachte hierbei die \textit{tail-rekursion} bei
  funktionalen Sprachen}
  
  \lstinputlisting[label=src:if_else_ternary_while.scala]{beispiele/if_else_ternary_while.scala}
  
  \item das Ergebnis von if \und while ist immer \texttt{Unit}    
\end{itemize}


\subsection{for-Schleife}
\begin{itemize}
  \item einfache Variante ist wie in Java:
  
  \lstinputlisting[label=src:for_easy.scala]{beispiele/for_easy.scala}
  
  \item verschachtelte Variante:
  
  \lstinputlisting[label=src:for_middle.scala]{beispiele/for_middle.scala}
  
  \item in for-Schleifen kann man auch guards packen:
  
  \lstinputlisting[label=src:for_guards.scala]{beispiele/for_guards.scala}
\end{itemize}


\subsection{try-catch, throw und finally}
\begin{itemize}
  \item throws bzw. try/finally funzt wie in Java:
  
  \lstinputlisting[label=src:throw_try_finally.scala]{beispiele/throw_try_finally.scala}
  
  \item try/catch ist anders:
  \begin{itemize}
    \item es gibt immer ein einen Wert zurück
    \item es weist einen default Wert zu, sobald alle anderen Tests
    durchgefallen sind
    
    \lstinputlisting[label=src:try_finally.scala]{beispiele/try_finally.scala}    
  \end{itemize}
\end{itemize}


\subsection{Enumerations}
Einfach Klassen von \texttt{Enumeration} erben lassen \und es ist dann
keine besondere Notation für die Elemente der Aufzählung nötig

\lstinputlisting[label=src:enumeration.scala]{beispiele/enumeration.scala}
\pagebreak


\section{Ausdrücke und Funktionen}
\begin{itemize}
  \item Unterschied zwischen \texttt{def x = e} \und \texttt{val x = e}:
  \begin{itemize}
    \item \texttt{def} - hier wird \texttt{e} nicht ausgewertet, sondern erst,
    wenn \texttt{x} verwendet wird
    \item \texttt{val} - hier wird \texttt{e} sofort 
    ausgewertet\footnote{sobald man \texttt{x} verwendet, ist der Ausdruck 
    \texttt{e} bereits vorhanden}
  \end{itemize}
  \item \ulab{Frage}: Wie werden Ausdrücke ausgewertet? \begin{itemize}
    \item schnappe die die am meisten links stehende Operation
    \item werte die Operanden aus
    \item verwende die Operation entsprechend mit den Werten der Operanden
  \end{itemize}
\end{itemize}


\subsection{Funktionen}
\begin{itemize}
  \item Funktionen können in Scala Symbole wie $+, -, *, and, ?$ enthalten
  \item Funktionen können die folgende Form
  haben: \texttt{Function[A, B]}, wobei \texttt{A} der Parametertyp 
  \und \texttt{B} der Rückgabewert ist
  
  $\Rightarrow$ andere Schreibweise für \texttt{Function[A, B]}:
  
  \begin{center}
    \texttt{A $=>$ B}
  \end{center}
    
  \item Funktione, welche andere Funktionen als Parameter nehmen werden
  \textit{high-order} Funktionen genannt
    \item falls man eine Variable Liste an Parametern haben möchte, dann muss *
  in die Parameterliste einer Funktionsdef setzen:
  
\lstinputlisting[label=src:method_declaration_4.scala]{beispiele/method_declaration_4.scala}
    
  \item man kann auch Schranken für Typen definieren. Im folgenden Beispiel müssen alle Typen vom Typ \texttt{Number} \oder von einer Subklasse von
  \texttt{Number} sein:
  
  \lstinputlisting[label=src:method_declaration_6.scala]{beispiele/method_declaration_6.scala}

\end{itemize}


\subsubsection{Verschachtelte Funktionen und Parameter}
\begin{itemize}
  \item   \lstinputlisting[label=src:nested_functions.scala]{beispiele/nested_functions.scala}
  
  fact kann man nur innerhalb des Scopes von factorial aufrufen, sonst kommt
  es zu einem Compilerfehler.
  
  \item weitergabe von Parametern innerhalb verschachtelten Funktionen:
  
  \lstinputlisting[label=src:parameter_passing_nested_functions.scala]{beispiele/parameter_passing_nested_functions.scala}  

\end{itemize}


\subsubsection{Parameter}
\begin{itemize}
  \item Funktionsparameter werden immer von Klammern eingeschlossen
  
  \begin{Beschreibungfett}[call-by-value]
    \item [call-by-value] Vorteil ist Vermeidung der wiederholten Auswertung 
    von Argumenten
    \item [call-by-name] hat den Vorteil, dass es die Parameter nicht 
    auswertet, sofern sie nicht in der Funktion verwendet werden
  \end{Beschreibungfett}
  
  call-by-value ist effizienter als call-by-name, aber call-by-value
  kann in $\infty$-loops geraten
    
  \item Scala benutzt per Def. call-by-value, aber kann auf call-by-name
  wechseln durch Voranstellung von $=>$:
  
  \lstinputlisting[label=src:vergleich_call_by_value_call_by_name_2.scala]{beispiele/comparison_call_by_value_call_by_name.scala}
  
\end{itemize}


\subsubsection{Callback}
Fkt. mit callback Fkt. haben folgende Syntax: 
  \textsc{() =$>$ Unit} und ist eine Funktion, die keine Parameter \und 
  kein return-Wert hat
  
  \lstinputlisting[label=src:callback.scala]{beispiele/callback.scala}


\subsubsection{Anonyme Funktionen}
\begin{itemize}
  \item doof, wenn man Funktionen einen Namen geben muss, wenn man sie
  nur einmal verwenden $\Rightarrow$ hierfür sind anonyme Funktionen da :)
  \item die Anwesenheit von anonymen Funktion wird durch die Syntax:
  \textsc{=$>$} gemacht
  
  \lstinputlisting[label=src:callback_anonymous.scala]{beispiele/callback_anonymous.scala}
\end{itemize}


\subsection{Schwanzrekursion}
\lstinputlisting[label=src:gcd.scala]{beispiele/gcd.scala}


\lstinputlisting[label=src:factorial.scala]{beispiele/factorial.scala}


\begin{itemize}
  \item gcd hat immer dieselbe Form, während bei factorial immer noch ein
  multiplikativer Faktor hinkommt
  \item bei Faktorial werden für die Multiplikatoren stets ein neuer
  Stack-Frame angelegt \und es braucht deshalb Platz proportional der
  Eingabe $\Rightarrow$ ist deswegen keine Schwanzrekursion
  
  $\Rightarrow$ im folgenden Code wird nun gezeigt, wie man Schwanzrekursion
  erzeugen kann:
  
  \lstinputlisting[label=src:nested_functions.scala]{beispiele/nested_functions.scala}
\end{itemize}


\subsection{Currying}
\begin{itemize}
  \item betrachten \texttt{sum}, bei der man die Grenzen a \und b nicht mehr
  angeben muss
  
  \lstinputlisting[label=src:currying.scala]{beispiele/currying.scala}
  
  \item wir werden nun Funktionen, die Funktionen zurückgegeben,
  behandelt?
  
  \lstinputlisting[label=src:currying_1.scala]{beispiele/currying_1.scala}
  
  hier wird \texttt{sum} zuerst zur Quadratfunktion \texttt{(x $=>$ x * x)}
  angewendet \und die reslutierende Funktion wird dann auf die Argumentenliste
  \texttt{(1, 10)} angewendet
  \item für Funktionen, die Funktionen zurückgeben, hat Scala eine besondere
  Syntax \und die obige sum-Funktion kann auch wie folgt kürzer geschrieben
  werden
  
  \lstinputlisting[label=src:currying_3.scala]{beispiele/currying_3.scala}
  
\end{itemize}
\pagebreak


\section{Klassen und Objekte}
\begin{itemize}
  \item Klasse für rationale Zahlen:
  
  \lstinputlisting[label=src:rationale_zahlen.scala]{beispiele/rational_numbers.scala}
  
  \item \textbf{private members}: durch spezielles Keyword gekennzeichnet
  \und können nicht außerhalb der Klasse angesprochen werden
  \item \textbf{Objekterstellung}\footnote{erfolgt nach 
  \textit{lazy evaluation}}:
  
  \lstinputlisting[label=src:objekt_anlegen.scala]{beispiele/object_creation.scala}
  
  
  $\Rightarrow$ mittels Punktnotation kann auf die Attribute zugegriffen
  werden
  \item \textbf{Vererbung}: jede Klasse erweitert eine Superklasse. Ist
  keine Klasse angegeben, so erbt es per \textit{default} von
  \texttt{scala.AnyRef}
  
  \lstinputlisting[label=src:vererbung.scala]{beispiele/vererbung.scala}
  
  \item eine Klasse erbt alle Methoden \und Variablen der Oberklasse, will
  man eine geerbte Methode überschreiben, so muss man das Schlüsselwort
  \textbf{override} verwenden
  
  \lstinputlisting[label=src:override.scala]{beispiele/override.scala}
    
  \item \textbf{Abstrakte Klassen}: 
  
  \lstinputlisting[label=src:abstrakte_klassen.scala]{beispiele/abstrakte_klassen.scala}
  
  \texttt{IntSet} ist als abstrakte Klasse gekennzeichnet, d.h. von ihr können
  keine Objekte erzeugt werden
  
  Implementierung einer abstrakten Klasse
  
  \lstinputlisting[label=src:implementierung_einer_abstrakten_klasse.scala]{beispiele/implementierung_einer_abstrakten_klasse.scala}
  
  \item \textbf{traits}: traits sind wie abstrakte Klassen, nur dass sie
  dafür geschaffen wurde, um an andere Klassen ergänzt zu werden
  
  \lstinputlisting[label=src:traits.scala]{beispiele/traits.scala}
  \item \textbf{objects}: statt class kann man auch objects davor schreiben
  \und dadurch ist das \textbf{Singleton-Pattern} sichergestellt:
  
  \lstinputlisting[label=src:object.scala]{beispiele/object.scala}
  
  \item jede Deklaration ohne ein Sichtbarkeits/Scopewort ist per default
  \textit{public}\footnote{dafür gibts kein Schlüsselwort}
  \item mit \texttt{equal} vergleicht man, ob Objekte den gleichen
  Werte besitzen
  \item mit == \und != vergleicht man Wertgleichheit

\end{itemize}


\subsection{Klassen}
\begin{itemize}
  \item werden in Packeten definiert \und spielen eine ähnliche Rolle wie
  in Java
  \item jedes Java-Packet ist auch eine Scala-Packet (vice versa)
  \item jede Klasse kann via \textit{mixin} von mehr als einer Klasse
  erben, denn per default kann nur von einer Klasse gererbt werden
  \item jede Java-Klasse wird als gewöhnliche Scala-Klasse angesehen \und 
  jedes Java-Interface kann als Scala-\textit{trait} angesehen werden
  \item ein Beispiel für eine verschachtelte Klasse:
  
  \lstinputlisting[label=src:nested_classes.scala]{beispiele/nested_classes.scala}

\end{itemize}


\subsection{Klassenimport}
\begin{itemize}
  \item Syntax:
  
  \lstinputlisting[label=src:import.scala]{beispiele/import.scala}
  
  \item mehrere Klassen \oder Objekte können vom selben Paket importiert werden, 
  indem sie einfach in \textit{brackets} geschrieben werden
\end{itemize}


\subsection{Klassenhierarchie}
\begin{itemize}
  \item in Scala ist alles, bis auf eine Methode eine Instanz von
  einer Klasse $\Rightarrow$ alle Primitven aus Java (wie \uline{z.B.} int) 
  werden als Instanzen behandelt \und dies wird bei Kompilierung gemacht
  \item \texttt{Any} ist die Top-Klasse, es hat zwei Unterklassen:
  \texttt{AnyVal} \und \texttt{AnyRef}
  \item \texttt{AnyVal}  basiert auf \textit{value classes}, also
  \textbf{boolean, byte, short, char, int, long, float, double}
  \item Mutterklasse aller Scala-Klassen ist \texttt{Scala.Any}
  \item am untersten Ende der Scala-Typen steht \texttt{scala.Null}
  \und \texttt{scala-Nothing}
  \item \texttt{scala.Null} ist ein \textit{subtype} von allen Referenztypen
  
  $\Rightarrow$ einzige Instanz ist die \textbf{null} Referenz
  \item \texttt{scala.Nothing} ist \textit{subtypen} von jeden anderen Typen
  
  $\Rightarrow$ von diesen Typen existieren keine Instanzen
  \item wenn man sich an die Namenskonventionen hält, dann sind
  die Scala-Repräsentanten der Primitiven Datentypen der JVM:
  \begin{itemize}
    \item \texttt{Int}
    \item \texttt{Long}
    \item \texttt{Double}
    \item \texttt{Float}
    \item \texttt{Boolean}
    \item \texttt{Char}
    \item \texttt{Byte}
  \end{itemize} 
  
  alle Unterklassen von der Klasse \texttt{AnyVal}
\end{itemize}


\subsection{Overriding}
\begin{itemize}
  \item muss man dann hinschreiben, wenn abgeleitete Klassen Methoden, Felderm
  Variablen usw. von ihren Elternklassen überschreiben wollen
  \item überschreibt man etwas, ohne keyword \itbf{override} zu verwenden
  gibts einen Fehler $\Rightarrow$ potentielle Fehler werden dadurch
  abgefangen
  \item Sachen, die als final deklariert sind, kann man nicht 
  \itbf{overriden}
\end{itemize}


\subsection{Abstraktion}
\begin{itemize}
  \item eine wichtige Aufgabe von Komponentensystemen ist, wie man von den
  erforderlichen Komponenten abstrahiert
  \item es gibt folgenden Formen der Abstraktion in Progg-Sprachen:
  \begin{enumerate}
    \item \textit{Parametrisierung} (typisch Funktional)
    \item \textit{abstract members} (typisch objekt-orientiert)
  \end{enumerate}

  \item die folgende Klasse \texttt{GenCell} ist generisch
  
  \lstinputlisting[label=src:gencell.scala]{beispiele/gencell.scala}
  
  \item ebenso wie Klassen können auch Methoden Typenparameter besitzen.
  
  die folgende Methode vertauscht den Inhalt von zwei Zellen:
  
  \lstinputlisting[label=src:gencell_swap.scala]{beispiele/gencell_swap.scala}
  
  \item Anwendung von swap:
  
  \lstinputlisting[label=src:gencell_swap_usage.scala]{beispiele/gencell_swap_usage.scala}
  
  Scala hat jedoch ein hochentwickeltes \textit{type inference system}, welches
  die korrekten Typen anhand der Argumente erkennt $\Rightarrow$ im obigen 
  Codeschnipsel zur Anwendung der swap-Methode kann man die Typangaben in den
  \textit{square brackets} auch weglassen
  \item \textbf{Varianz}: 
  \begin{itemize}
    \item Scala erlaubt die Varianz von Typparametern durch die Zeichen + \und 
    -
    \item + $\ldots$ vor einem Parameter sagt aus, dass der Konstruktor
    \itbf{covariant} ist
    \item - $\ldots$ vor einem Parameter sagt aus, dass der Konstruktor
    \itbf{contravariant} ist
  \end{itemize}
\end{itemize}


\subsection{Companion Objekte}
\begin{itemize}
  \item wenn eine Klasse \und ein Objekte innerhalb einer Datei, im selben
  Packet den gleichen Namen haben, werden diese \textit{Companion Objekte}
  genannt
  \item \textbf{Apply}: wird als \textit{factory} Methode verwendet
  
  \lstinputlisting[label=src:apply.scala]{beispiele/apply.scala}
  
  \item \textbf{Unapply}: wirkt irgendwie als Extraktionmechanismus von
  bestimmten Werten einer Instanz $\Rightarrow$ Pattern Matching
  benutzt diesen Mechanismus ausführlich
  
  \lstinputlisting[label=src:unapply.scala]{beispiele/unapply.scala}
\end{itemize}


\subsection{Komposition}
$\Rightarrow$ hat flexible modulare Mixin-Komposition Konstrukte für 
Klassen-Komposition


\begin{itemize}
  \item fangen einfach mal mit einem kleinen Beispiel an:
  
  \lstinputlisting[label=src:abstract_list_iterator.scala]{beispiele/abstract_list_iterator.scala}
  
  \begin{itemize}
    \item \textbf{traits} ist eine spezielle Form einer abstrakten Klasse, welche
    keine Werte für den Parameter für den Konstruktor hat
    \item traits können in allen Kontexten verwendet werden, in denen abstrakte
    Klassen auftauchen
    \item nur traits können als mixins verwendet werden
  \end{itemize}
  
  \item \textbf{mixin-class composition}: betrachten folgende Interatoren
  
  \lstinputlisting[label=src:iterators_for_mixin_class_composition.scala]{beispiele/iterators_for_mixin_class_composition.scala}
  
  \begin{itemize}
    \item nun wollen die Funktionen des \texttt{RichIterators} und des
    \texttt{StringIterators} in einer Klasse verwenden $\Rightarrow$ mit
    Einfachvererbung \und Interfaces kann man das nicht machen
    \item \uline{Idee}: \textit{mixin-class composition}
    
    \lstinputlisting[label=src:mixin_class_composition.scala]{beispiele/mixin_class_composition.scala}
    
  \end{itemize}
\end{itemize}


\subsection{Dekomposition}
von Objekten via Pattern-Matching


\begin{itemize}
  \item wollen einen simplen Taschenrechner für algebraische Berechnungen \und 
  der Plus-Operation implementieren:
  
  \lstinputlisting[label=src:algebraic_calculator.scala]{beispiele/algebraic_calculator.scala}
  
  \item so ein Ansatz verlangt, dass alle Operationen zu einer bestimmten
  Struktur durchwandert werden
  
  \begin{itemize}
    \item intern definierte Methoden müssen deswegen ebenfalls ungewollt
    durch die ganze Struktur gelegt werden $\Rightarrow$ DRY wird
    verletzt
  \end{itemize}
\end{itemize}


\ulbf{Pattern Matching über Klassenhierarchie}


\begin{itemize}
  \item in FP sind Datenstrukturen von ihren Operationen getrennt  
  \item während Datenstrukturen gewöhnlich durch algebraische Datenstrukturen
  definiert sind, benutzen Operationen auf solchen Datentypen 
  \itbf{pattern matching} als Grundprinzip der Dekomposition
  \item durch \itbf{pattern matching} kann man eine einzelne 
  \texttt{eval}-Funktion implementieren, ohne das künstliche Zusatzfunktion
  aufzusetzen
  \item Klassen werden mit \textbf{case} \enquote{getagt}:
  
  \lstinputlisting[label=src:algebraic_calculator_case.scala]{beispiele/algebraic_calculator_case.scala}
  \item nun folgt die Implementierung der \texttt{eval}-Funktion nach dem
  Pattern-Matching Prinzip:
  
  \lstinputlisting[label=src:algebraic_calculator_pattern_matching.scala]{beispiele/algebraic_calculator_pattern_matching.scala}
  
  \item der matchende Ausdruck $x$ \textbf{match} $\{ case\: pat_1 => e_1
  case\: pat_2 => e_2 \ldots \}$ matchd den Wert $x$ gegen die Muster $pat_1, 
  pat_2, \ldots$
  
  
  $\Rightarrow$ dadurch können neue Funktionen leicht zu einem bestehenden
  System hinzugefügt werden
\end{itemize}


\subsection{Case-Klassen}
\begin{itemize}
  \item es wird einfach das Schlüsselwort \textbf{case} vor Klassen bzw. 
  Objekten geschrieben
  \item Case-Klassen haben implizit eine Konstruktor-Funktion, welche denselben
  Namen wie die Klasse trägt
  \item Case-Klassen \und Case-Objekte haben implizit die Methoden
  \texttt{toString, equals} \und \texttt{hashCode} implementiert \und 
  überschreiben die Methoden von \texttt{AnyRef}; sie haben implizite 
  getter-Methoden, um an die Argumente der Konstruktoren zu gelangen
  \item Instanzen von Case-Klassen können ohne die \texttt{new}-Anweisung
  erzeugt werden
  
  \lstinputlisting[label=src:case_class.scala]{beispiele/case_class.scala}  
  
  \item Case-Klassen erlauben die Erstellung von \textit{patterns}, welche
  zu case-class Konstruktoren gehören:
  
  \lstinputlisting[label=src:case_class_one_more_example.scala]{beispiele/case_class_one_more_example.scala}
  
\end{itemize}


\subsection{Pattern Matching}
\begin{itemize}
  \item ist eine generalsierte \texttt{switch}-Anweisung für Klassenhierarchien
  \item anstelle der switch-Anweisung gibt es eine \textbf{match}-Operation
  
  \lstinputlisting[label=src:match.scala]{beispiele/match.scala}

\end{itemize}


\subsection{traits}
\begin{itemize}
  \item in Scala kann man traits in Objekte erst bei Instanziierung einbinden
  \item traits können auch als abstrakt deklariert haben
  \item traits haben ansonsten den gleiche Aufbau wie eine normale
  Klasse
  \item traits unterstützen nicht beliebige Konstruktoren \und nehmen auch
  keine Argumente für ihre Konstruktoren auf
  
  $\Rightarrow$ können keine Argumente an ihre Elternklassen weitergeben
  
  \lstinputlisting[label=src:trait_creation.scala]{beispiele/trait_creation.scala}
  
  $\Rightarrow$ Reihenfolge der Abarbeitung der trais ist von links nach
  rechts

  \item \textbf{Klassen \oder traits?} falls ein traits mehr als einmal als 
  Elternteil von anderen Klassen dient, so als Klasse machen; vermeide 
  konkrete Felder in traits, welche nicht mit geeigneten default-Werten
  initialisiert werden können $\Rightarrow$ verwende lieber abstrakte Felder
\end{itemize}
\pagebreak


\section{Generische Typen und Methoden}
\begin{itemize}
  \item haben einen Stack für Integer
  
  \lstinputlisting[label=src:stack_integer.scala]{beispiele/stack_integer.scala}
  
  \item diesen Stack durch \textbf{Typen Parameter} ganz leicht generisch machen
  
  \lstinputlisting[label=src:stack_generisch.scala]{beispiele/stack_generisch.scala}
  
  \item dasselbe Prinzip kann man auch bei Methoden anwenden \und generische
  Methoden sind auch ein Ausdruck von Polymorphi:
  
  \lstinputlisting[label=src:generische_funktionen.scala]{beispiele/generische_funktionen.scala}
\end{itemize}


\subsection{Tuples}
\begin{itemize}
  \item manchmal möchte man, dass eine Funktion mehr als ein Ergebnis
  zurückgibt
  
  \lstinputlisting[label=src:tuples.scala]{beispiele/tuples.scala}

  \item um auf Elemente von Tuppeln zuzugreifen verwendet man
  \texttt{t.\_N}, wobei N für das gewünschte Element steht
  \item ein anderes Beispiel mit der \texttt{tupleator} Methode, die aus den
  Argumenten ein Tupel entsprechend der Anzahl der Argumente generiert
  
  \lstinputlisting[label=src:tupleator.scala]{beispiele/tupleator.scala}

\end{itemize}
\pagebreak


\section{Listen}
\begin{itemize}
  \item Listen in Scala unterscheiden sich folgendermaßen von
  anderen Sprachen: \begin{enumerate}
    \item sind unver-$\Delta$
    \item haben rek. Struktur
    \item haben viel mehr Ops. als Arrays
  \end{enumerate}
  
  \lstinputlisting[label=src:listen.scala]{beispiele/listen.scala}
  
  \item Vorteile Unver-$\Delta$:
  \begin{itemize}
    \item weniger globale Zustände $\Rightarrow$ weniger Dinge können 
    sich $\Delta$
    \item Fkt. werden weniger anfällig für globale Zustände von Variablen 
    \und Funktionen werden mehr transformativ $\Rightarrow$ Methoden
    referenzieren viel weniger auf den externen Zustand von Variablen
    \item solche Methoden sind leichter mit automatischen 
    Tests\footnote{\texttt{ScalaCheck}} durchzuführen
  \end{itemize}
\end{itemize}


\subsection{List[T]}
\begin{itemize}
  \item List[T] ist eine verkettete Liste vom 
  Typ T\footnote{ist also verkettet} $\Rightarrow$ ist sequentielle Liste,
  welche Javas primitve Datentypen beinhaltet (\texttt{Int, Float,
  Double}), da sich um 
  \textbf{boxing}\footnote{also Umwandlung von primitiven Datentypen in
  Objekten} kümmert
  \item \textbf{Listen-Konstruktoren}: \texttt{Nil} ist Repräsentant für
  eine leere Liste, \texttt{::} (cons genannt) \uline{z.B.} 
  \texttt{x :: xs} $\Rightarrow$ Liste mit ersten Element \texttt{x}
  und zweiten Element/Liste \texttt{xs}
  
  \lstinputlisting[label=src:cons.scala]{beispiele/cons.scala}
  
  $\Rightarrow$ mit \texttt{Nil} drücken wir die leere Liste aus
  \item \textbf{Listen sind homogen}\footnote{d.h. innerhalb einer Liste
  müssen alle Elemente vom selben Typ sein}:
  
  \lstinputlisting[label=src:listen_1.scala]{beispiele/listen_1.scala}
  
  \item \textbf{Item an Liste dranhängen}:
  
  \lstinputlisting[label=src:collection_append.scala]{beispiele/collection_append.scala}
  
  die alte Variable x bleibt unverändert und an die neue Liste mit den Wert
  99 als head wird alte Liste x drangehangen\footnote{läuft in O(1)}
  \item \textbf{Listen mergen}: via \texttt{:::}
  
  \lstinputlisting[label=src:collection_mergen.scala]{beispiele/collection_mergen.scala}
  
  \item \textbf{typische Listen-Ops}:
  
  \lstinputlisting[label=src:collection_ops.scala]{beispiele/collection_ops.scala}
  
  \item \texttt{filter} funzt bei jeder Collection, welche einen
  bestimmten Typ enthält:
  
  \lstinputlisting[label=src:collection_universel.scala]{beispiele/collection_universel.scala}
  
  $\Rightarrow$ konvertieren einen String in \texttt{List[Char]} \und 
  filtern via Methode aus Java aus dieser Char-Liste die Zahlen heraus
\end{itemize}


\subsection{Transformation}
\begin{itemize}
  \item \texttt{map} transformiert alle Elemente einer Collection
  basierend auf eine Funktion:
  
  \lstinputlisting[label=src:collection_transformation_map.scala]{beispiele/collection_transformation_map.scala}
  
  
  mit Listen kann man komplexe DB-Queries machen
  \und Elemente in Liste ausgeben:
  
  \lstinputlisting[label=src:collection_db_query.scala]{beispiele/collection_db_query.scala}
  
  \item \texttt{List} hat \texttt{sort}-Methode:
  
  \lstinputlisting[label=src:collection_sort.scala]{beispiele/collection_sort.scala}
  
  \item \texttt{reduceLeft}: Operation auf adjazenten Elemente einer
  Collection rekursiv durchführen bis alles abgegrast ist:
  
  \lstinputlisting[label=src:collection_reduce_left.scala]{beispiele/collection_reduce_left.scala}
  
  \item \texttt{foldLeft} arbeitet wie \texttt{reduceLeft}, nur dass es 
  einen \textit{Seed} als Startpunkt nimmt, wobei der Seed-Typ den Rückgabewert von \texttt{foldLeft} ist:
  
  \lstinputlisting[label=src:collection_foldLeft.scala]{beispiele/collection_foldLeft.scala}
  
  \item geschachtelten Collection erstellen:
  
  \lstinputlisting[label=src:collection_nested.scala]{beispiele/collection_nested.scala}
  
  wollen wir die Ergebnisse einer geschachtelten Schleife 
  \enquote{platten}, so \texttt{flatMap}-Methode verwenden
  
  \item \textbf{for-Comprehension}\footnote{for-Comprehension ist 
  kein Schleifenkonstrukt sondern syntaktische Vereinfachung}
  \begin{itemize}
    \item angenommen haben Liste von Personen mit \texttt{namen} \und 
    \texttt{age} \und wir wollem die Namen aller Personen ausgeben, die
    alle über 20 sind
    
    \lstinputlisting[label=src:for_comprehension.scala]{beispiele/for_comprehension.scala}
    
    \item genereller Aufbau von for-comprehension:
    
    \begin{shadowminipage}
    \lstinputlisting[label=src:for_comprehension_generell.scala]{beispiele/for_comprehension_generell.scala}
    \end{shadowminipage}
    
    
    s $\ldots$ ist eine Sequenz von \textit{Generatoren, Definitionen}
    \und \textit{Filtern}
    \item ein \textit{Generator} hat die Form 
    \texttt{\textbf{val} x $<-$ e}, wobei
    \texttt{e} eine Liste mit Werten ist \und an \texttt{x} 
    werden sukzessiv die Elemente aus \texttt{e} gehangen
    \texttt{x} ist ein Name für die Werte von \texttt{e}
    \item ein \textit{Filter} ist ein Ausdruck \texttt{f} vom 
    booleschen Typ
    \item angenommen wir wollen das Produkt der Zahlen von 1 bis 10
    zwischen den geraden \und ungeraden Zahlen bilden:
    
    \lstinputlisting[label=src:collection_for_comprehesion.scala]{beispiele/collection_for_comprehesion.scala}
 
  \end{itemize}
\end{itemize}


\subsection{Tupel}
\begin{itemize}
  \item wollen Fkt. schreiben, die 3 return-Werte hat:
  
  \lstinputlisting[label=src:tupel_example.scala]{beispiele/tupel_example.scala}
  
  \begin{itemize}
    \item der Compiler übersetzt \texttt{(Int, Double, Double)} in
    \texttt{Tuple3[Int, Double, Double]}
    \item \texttt{foldLeft} hat zwei Parameter: t $\ldots$ steht für 
    Tuple3[Int, Double, Double]
    \item der Rückgabewert der Funktion ist ein neues Tupel
  \end{itemize}
  \item man kann Tupel auf viele verschiedene Arten anlegen:
  
  \lstinputlisting[label=src:tupel_creation.scala]{beispiele/tupel_creation.scala}
\end{itemize}


\subsection{Map[K,V]}
\begin{itemize}
  \item \texttt{Map} ist Sammlung von key/value Paaren
  \item \texttt{Map} Klasse ist unver-$\Delta$
  \item jeder beliebige value kann von einen eindeutigen Schlüssel
  beschrieben werden
    
  \item wenn wir auf einen Schlüsselzugreifen wollen, den es nicht
  gibt wird eine Exception geworfen (was auch Sinn macht, denn man
  kann ja nicht auf was zugreifen, was es gar nicht gibt):
 
  \lstinputlisting[label=src:map_examples.scala]{beispiele/map_examples.scala}

  macht man den \texttt{Map}-Zugriff mit get, so wird die 
  \texttt{Option} (\texttt{Some} \oder \texttt{None}) zurückgegeben
  \item mit \texttt{-= key} kann man Elemente aus einer Map entfernen
  \item mit \texttt{.contains} kann man testen, ob ein Schlüssel in der
  der Map enthalten ist
\end{itemize}
\pagebreak


\section{Funktionen}
\begin{itemize}
  \item FKt. sind in Scala eine Instanz von Klassen:
  
  \lstinputlisting[label=src:functions.scala]{beispiele/functions.scala}
  
  \item \textbf{Funktionen als Parameter übergeben}:
  
  definieren eine Methode w42, die eine Funktion als Parameter übernimmt:
  
  \lstinputlisting[label=src:function_as_parameter.scala]{beispiele/function_as_parameter.scala}

\end{itemize}


\subsection{Partielle Anwendungen}
\begin{itemize}
  \item \textbf{in Scala ist alles bis auf Methoden eine 
  Instanz}\footnote{Methoden sind keine Funktionen in Scala}
  \item Methoden werden an Instanzen angehangen \und angewendet
  \item in Scala können wir partiell angehauchte Funktionen von Methoden
  her ableiten:
  
  \lstinputlisting[label=src:partial_functions.scala]{beispiele/partial_functions.scala}
  
  \texttt{p} braucht einen zweiten Parameter, um die Anforderungen an
  die Funktion plus 42 zu erfüllen \und wir sagen \texttt{p} ist
  partielle Anwendung von \texttt{plus}
  
  \item partielle Methodendefs können mit der folgenden Syntax besser
  beschrieben werden:
  
  \lstinputlisting[label=src:partial_notation.scala]{beispiele/partial_notation.scala}
  
  
  durch diese Notation kann man Codeblöcke als Parameter übergeben:
  
  \lstinputlisting[label=src:partial_codeblocks.scala]{beispiele/partial_codeblocks.scala}
\end{itemize}


\subsection{Typparameter}
Typparameter definieren den Typ von Parametern \oder den 
Rückgabewert der Fkt.:
  
  \lstinputlisting[label=src:typparameter_functions.scala]{beispiele/typparameter_functions.scala}


\subsection{Funktionen in Container}
\begin{itemize}
  \item Funktionen sind Instanzen \und deswegen kann man alles, was man
  mit Instanzen machen kann auch mit Funktionen machen
  \item Array von Funktionen\footnote{erinnert frappierend an
  Wörterbuch der Algorithmen}:
  
  \lstinputlisting[label=src:function_container.scala]{beispiele/function_container.scala}  
\end{itemize}
\pagebreak


\section{Pattern-Matching}
\begin{itemize}
  \item \textbf{Fibonaccizahlen} verschiedenen Varianten:
  
  \lstinputlisting[label=src:pattern_matching_fibonacci.scala]{beispiele/pattern_matching_fibonacci.scala}
  
  \item \textbf{Matching Any Type}:
  
  \lstinputlisting[label=src:matching_any_type.scala]{beispiele/matching_any_type.scala}
  
  \item \textbf{Datentypen testen}: schreiben eine Methode, die testet,
  ob ein hereinkommendes Objekt ein \texttt{String}, \texttt{Integer} \oder 
  was anderes ist
  
  \lstinputlisting[label=src:pattern_datatypes.scala]{beispiele/pattern_datatypes.scala}
  
  \item \textbf{Case-Klassen} gehören auch zu dieser Klasse:
  
  \lstinputlisting[label=src:pattern_matching_case_class.scala]{beispiele/pattern_matching_case_class.scala}
  
  \item \textbf{verschachteltes Pattern-Matching in case-Klassen}:
  
  \lstinputlisting[label=src:pattern_matching_nested.scala]{beispiele/pattern_matching_nested.scala}

  \item \textbf{Pattern-Matching Listen}:
  
  \lstinputlisting[label=src:pattern_matching_lists.scala]{beispiele/pattern_matching_lists.scala}
  
\end{itemize}
\pagebreak


\section{Varianz}
Regeln festlegen, nach denen parametrisierte Typen als Parameter übergeben
werden können


\subsection{Varianzregeln}
\begin{itemize}
  \item $\Delta$ Container sollten invariant sein
  \item unver-$\Delta$ Container sollten kovariant sein
  \item die Inputs von Transformationen sollten kontravariant sein
  \und die Outputs von Transformationen sollten kovariant sein
\end{itemize}
  

\subsection{Invariante Parametertypen}
\begin{itemize}
  \item in Scala ist \texttt{Array[T]} \itbf{invariant}, d.h. 
  man kann nur \texttt{Array[String]} an \texttt{foo(a: Array[String])}
  übergeben
  \item invariante Typparameter schützen, wenn wir mit
  \textit{veränderlichen} Datentypen hantieren
\end{itemize}


\subsection{Kovariante Parametertypen}
\begin{itemize}
  \item Kennzeichen: \texttt{+} vorm Typparameter, \uline{z.B.} 
  \texttt{List[+T]}
  \item Anwendung: wenn wir mit \textit{read-only} container umgehen
  
  \lstinputlisting[label=src:covariant_parameter_types.scala]{beispiele/covariant_parameter_types.scala}
\end{itemize}
\pagebreak


\section{Scalas Objekt System}
\begin{itemize}
  \item das sogenannte \textbf{Predef Objekt} lädt automatisch
wichtige Sachen in ein Scala Programm
  \item Objekte werden automatisch und \textit{lazy} zur Laufzeit
  instamziiert 
  \item 
\end{itemize}


\subsection{Typhierarchie}
siehe folgendes Bild

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{bilder/typhierarchie.png}
\end{center}
\end{figure}


\begin{itemize}
  \item alle \texttt{AnyVal} Instanzen sind immutable \und 
  alle \texttt{Anyvalue} Typen sind \textit{abstract final}
\end{itemize}


\subsection{Linearisierung der Objekthierarchie}
betrachte folgendes Beispiel:

\lstinputlisting[label=src:linearization_object_hierarchiy.scala]{beispiele/linearization_object_hierarchiy.scala}


hier ist der Linearisierungsalso, den Scala verwendet:

\begin{enumerate}
  \item Put the actual type of the instance as the first element.
  \item Starting with the rightmost parent type and working left, compute the linearization
of each type, appending its linearization to the cumulative linearization. (Ignore
ScalaObject, AnyRef, and Any for now.)
  \item Working from left to right, remove any type if it appears again to the right of the
current position.
  \item Append ScalaObject, AnyRef, and Any.
\end{enumerate}
\pagebreak


\section{FP in Scala}


\subsection{Was FP ist}
\begin{itemize}
  \item haben keine Seiteneffekte, d.h. Analyse, Testen \und debuggen
  werden leichter
  \item \textit{referential transparency}, d.h. man kann eine Funktion
  in jeden beliebigen Kontext aufrufen \und muss keine Sorgen um den
  Kontext machen in dem die Funktion aufgerufen wird
  \item in FP sind Variablen immutable
\end{itemize}


\subsection{FP in Scala}
\begin{itemize}
  \item \ulab{Merke}: eine Funktion, die \texttt{Unit} zurückgibt,
  hat pure Seiteneffekte, denn ansonsten ist die Funktion sinnlos,
  da sie ja nichts zurückgibt
  
  \lstinputlisting[label=src:fp_list_map.scala]{beispiele/fp_list_map.scala}
  
  man kann die anonyme Funktion auch auf ein val drücken.
  
  \lstinputlisting[label=src:fp_list_map_value.scala]{beispiele/fp_list_map_value.scala}
  
  $\Rightarrow$ Faktor ist kein formaler Parameter sondern eine
  Referenz zu einer Variable in einen bstimmten scope, d.h. 
  der Compiler kreiert ein \textit{closure}
\end{itemize}


\subsection{Rekursion}
\begin{itemize}
  \item verhindert mutable Variablen
  \item aber Performanz-Overheadn \und Risiko des Stackoverflows
  \item Performaz-Prosb können mit \textit{memorization} \und 
  Stackoverflows können durch Umwandlung in eine spezielle 
  Schleife (Tail Calls \und Tail-Call Optimierung) verbessert
  werden
\end{itemize}


\subsection{Tail Calls und Tail-Call Optimierung}
\begin{itemize}
  \item Tail Call, d.h. wenn eine Funktion sich erst bei ihren
  finalen Durchlauf selbst aufruft $\Rightarrow$ es ist die leichteste
  Art der Rekursion, die man in eine normale Schleife umwandeln kann
  \item Schleifen verhindern die Gefahr eines Stackoverflows
  
  \lstinputlisting[label=src:factorial_recursive_and_tail_call.scala]{beispiele/factorial_recursive_and_tail_call.scala}
\end{itemize}


\subsection{Funktionale Datenstrukturen}
\begin{itemize}
  \item \textbf{Listen}: tauchen ganz oft in FP auf
  
  \lstinputlisting[label=src:lists_fp.scala]{beispiele/lists_fp.scala}
  
  \item \textbf{hash/dictionary/map}
    
  \item \textbf{Mengen}: sind wie Listen, aber ihnen kann jedes
  Element nur einmal vorkommen; Element Iteration geht in O(n)
\end{itemize}


\subsection{Traversieren, Mapping, Filtering, Folding und Reducing}
\begin{itemize}
  \item traveriseren geht mit der \texttt{foreach}:
  
  \lstinputlisting[label=src:foreach.scala]{beispiele/foreach.scala}
  
  \item \texttt{map}: wandelt eine Collection in eine neue Collection um,
  in der die Anzahl der Elemente gleich der Anzahl der Ursprungscollection
  ist
  
  \lstinputlisting[label=src:map.scala]{beispiele/map.scala}
  
  \item \texttt{filter} wird verwendet, um beim Traversieren durch eine
  Collection bestimmte Elemente herauszufiltern:
  
  \lstinputlisting[label=src:filter.scala]{beispiele/filter.scala}
  
  \item \texttt{folding} \und \texttt{reducing} werden beide verwendet, um
  eine collection zu schrumpfen, wobei folding immer mit einem 
  \textit{seed} beginnt:
  
  \lstinputlisting[label=src:folding_reducing.scala]{beispiele/folding_reducing.scala}  
\end{itemize}


\subsection{Pattern Matching}
\begin{itemize}
  \item ist das für FP, was Kapselung für OOP ist
  \item Pattern Matching ist ein eleganter Weg, um Objekte so zu zerlegen,
  dass sie in der erforderliche Verarbeitung passen
\end{itemize}


\subsection{Partielle Funktionen}
\begin{itemize}
  \item wenn an eine Funktion ein Unterstrich übergeben wird, dann handelt
  es sich um eine partielle Funktionen
  \item partielle Funktionen sind Aurücke, in denen nicht alle Argumente 
  einer Funktion auch von der Funktion übernommen werden
  
  \lstinputlisting[label=src:partial_functions_easy.scala]{beispiele/partial_functions_easy.scala}  
\end{itemize}


\subsection{Currying}
\begin{itemize}
  \item stammt vom Mathematiker Haskell Curry \und transformiert eine Funktion, die mehrere Parameter nimmt in eine Kettenfunktion, die nur einen
  Parameter nimmt
  \item in Scala werdem curried Funktion mit mehreren Parameterlisten
  definiert:
  
  \lstinputlisting[label=src:curried_functions.scala]{beispiele/curried_functions.scala}
  
  \item \ulab{Frage}: Wann verwendets man? Wenn man eine spezialisierte
  Funktion hat, die nur für bestimmte Daten geignet ist
\end{itemize}


\subsection{Implicits}
\begin{itemize}
  \item es kann manchmal vorkommen, dass man eine Instanz eines Typs hat 
  \und man diesen Typ in einen Kontext einsetzen möchte, in den es einen
  anderen aber vielleicht ähnlichen Typ geht
  
  $\Rightarrow$ Schlüsselwort \texttt{implizit} verwenden
  
  \lstinputlisting[label=src:implicit.scala]{beispiele/implicit.scala}  
\end{itemize}


\subsection{Lazy Vals}
\begin{itemize}
  \item das Schlüsselwort \texttt{lazy} benutzen:
  
  \lstinputlisting[label=src:lazy_vals.scala]{beispiele/lazy_vals.scala} 
  \item wenn man eine Variable als lazy deklariert, dann sollte man auch alle
  Verwendungen davon ebenfalls auf \textit{lazy} stellen 
\end{itemize}
\pagebreak


\section{Scala Typsystem}
\begin{itemize}
  \item Scala ist eine statisch typisierte Sprache \und das Typsystem ist 
  hier am fortschrittlichsten von allen Progsprachen, da es FP \und 
  OOP Benefits vereint
\end{itemize}


\subsection{Parametriesierte Typen}
\begin{itemize}
  \item bla
\end{itemize}


\subsection{Typen Bounds}
\begin{itemize}
  \item \texttt{A $<:$ AnyRef} means any type \texttt{A} that is a subtype of \texttt{AnyRef}
  \item bla, wurde an anderer Stelle besser erklärt
\end{itemize}


\subsection{Nothing und Null}
\begin{itemize}
  \item \texttt{Null} ist \texttt{final trait} \und kann nur eine Instanz haben
  \item \texttt{Nothing} ist \texttt{final trait} \und hat keine Instanz
\end{itemize}


\section{Fragen}
\begin{enumerate}
  \item Was sind \textbf{traits}?
  \begin{itemize}
    \item Ist eine besondere Variante eines \itbf{mixins}\footnote{zusammengehöriges, mehrfach verwendbares Bündel von Funktionalität bezeichnet, das zu einer Klasse hinzugefügt werden kann}. Ein Trait besitzt 
    eine gemeinsame Basisklasse mit der Klasse, auf die das Trait 
    angewendet wird.
  \end{itemize}
  \item Was ist der Unterschied zwischen val \und var?
  \begin{itemize}
    \item Variablen können in Scala jeweils den Wert 
    \textit{assign-once} \oder \textit{asign-many} haben
    \item \textit{assign-once}: mit \texttt{val} (ähnlich final
    in Java)
    \item \textit{assign-many}: mit \texttt{var}
    
    $\Rightarrow$ am besten immer val verwenden, denn je weniger
    sich Dinge $\Delta$ können, desto weniger Fehler können sich
    in den Code schleichen
  \end{itemize}
  \item Was drückt der folgende Ausdruck aus: $type S <: Subject$? Also was
  macht das $<:$?
  \item \textit{subclassing} bei mixins?
  \item \textbf{case-Klassen} generieren automatisch \textit{factory method} 
  mit denselben Argumenten als Primärkonstruktor
  \item Was sind \itbf{Views}\footnote{\textit{implicit conversions between
  types}; sie werden typischerweise angelegt, um neue Funktionalitäten
  für einen davorexistierenden Typ zu ergänzen}? Was ist im selben Zusammehang der 
  \textbf{implizit} Parameter\footnote{Argumente hierfür können bei einem
  Methodenaufruf weggelassen werden}?
  \item Was versteht man unter kontravariante Parametertypen?
\end{enumerate}



\subsection{Temproräres für DA}


\subsubsection{Statische versus Dynamsich typisierte Sprachen}
\begin{itemize}
  \item Typing $=_{df}$ \textit{A type system is a tractable syntactic method for preserving the absence of certain
program behaviors by classifying phrases according to the kinds of values they
compute.}

  \item ein Typsystem erlaubt es dem System zu sagen, was alles nicht
  stattfinden soll
  \item ein Typsystem kann verschiedene Fehler abfangen: \textit{like unsupported
operations on particular data structures, attempting to combine data in an undefined
way (e.g., trying to add an integer to a string), breaking abstractions, etc.
}
  \item in \itbf{statischer Typisierung} ist die Variable für seine gesamte Lebenszeit an einen Typ gebunden \und kann diesen nicht ändern
  \item in \itbf{dynamischer Typisierung} ist der Typ zum Wert \und 
  nicht zur Variable gebunden $\Rightarrow$ \textit{duck typung}; es wird
  deswegen von dynamik gesprochen, da der Typ einer Variable erst dann
  ausgewertet wird, wenn es zur Laufzeit verwendet wird
  \item Scala ist eine statisch typisierte Sprache
\end{itemize}


\subsubsection{Typinferenz}
\begin{itemize}
  \item darunter versteht man, dass man den Typ einer Variable schon anhand
  des Kontextest bestimmen kann (\uline{z.B.} \texttt{x = 1+ 3} $\Rightarrow$ 
  Compiler denkt sich also, dass \texttt{x} Integer ist)
\end{itemize}


\section{Sachen für MT}
\begin{itemize}
  \item \textbf{Dienst-orientiertes Komponenten-Model}
  \begin{itemize}
    \item Scalas Abstraktion kann als Basis für Dienst-orientiertes 
    Komponenten-Model gesehen werden
    \item Software-Komponenten sind Berechnungseinheiten, die eine wohlgeformte
    Menge von Diensten definieren
    \item in Scala gehören Software-Komponenten zu Klassen \und \textit{traits}
    \item konkrete \textit{Members} einer Klasse \oder \textit{traits} stellen
    die angebotenen Dienste dar, während \textit{derefered Members} als
    benötigte Dienste angesehen werden können
    \item die Komposition von Komponenten basiert auf \textit{mixins}, welche
    es Proggern erlauben, größere Komponenten aus kleineren zu bauen
    \item größte Vorteil gegenüber traditionelle black-box Komponenten ist,
    dass die Komponenten erweiterbare Entitäten sind $\Rightarrow$ wegen
    \textit{subclassing} \und \textit{overriding}
  \end{itemize}
\end{itemize}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       __       __  .___________.
%     |  |     |  | |           |
%    |  |     |  | `---|  |----`
%   |  |     |  |     |  |     
%  |  `----.|  |     |  |     
% |_______||__|     |__|     
%
% Literatur
% \end{comment}
\begin{comment}
\addcontentsline{toc}{section}{Literatur}
\bibliographystyle{acm}
\bibliography{literatur}
\end{comment}
\end{document}
